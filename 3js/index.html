 <!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - instanced particles - billboards - colors</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
	<link type="text/css" rel="stylesheet" href="reset.css">

	<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
</head>
<body>

	<div id="info">
		<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - particles river - colors
		<div id="notSupported" style="display:none">Sorry, your graphics card + browser does not support hardware instancing</div>
	</div>

	<div id="content-container">
		<div class="section">
			<div class="container">
				<div class="title">
					<div><h1>Lenin Ugalde</h1><h3>Software Engineer</h3></div>
				</div>
			</div>
		</div>
		<div class="section">
			<div class="container">
				<div class="about-me">
					<p class="txt">A software engineer experienced with the Design, Development, Maintenance, Test and Evaluation of High quality computer software, web and mobile applications, always learning and adapting to new technologies, exploring new creative and optimal solutions.</p>
				</div>
			</div>
		</div>
		<div class="section"></div>
		<div class="section"></div>
	</div>


	<script id="vshader" type="x-shader/x-vertex">
		precision highp float;
		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;
		uniform float time;

		attribute vec3 position;
		attribute vec2 uv;
		attribute vec3 translate;

		varying vec2 vUv;
		varying float vScale;

		void main() {

			vec4 mvPosition = modelViewMatrix * vec4( translate, 1.0 );
			vec3 trTime = vec3(translate.x + time,translate.y + time,translate.z + time);
			float scale =  sin( trTime.x * 2.1 ) + sin( trTime.y * 3.2 ) + sin( trTime.z * 4.3 );
			vScale = scale;
			scale = scale * 10.0 + 10.0;
			mvPosition.xyz += position * scale;
			vUv = uv;
			gl_Position = projectionMatrix * mvPosition;

		}
	</script>

	<script id="fshader" type="x-shader/x-fragment">
		precision highp float;

		uniform sampler2D map;

		varying vec2 vUv;
		varying float vScale;

		// HSL to RGB Convertion helpers
		vec3 HUEtoRGB(float H){
			H = mod(H,1.0);
			float R = abs(H * 6.0 - 3.0) - 1.0;
			float G = 2.0 - abs(H * 6.0 - 2.0);
			float B = 2.0 - abs(H * 6.0 - 4.0);
			return clamp(vec3(R,G,B),0.0,1.0);
		}

		vec3 HSLtoRGB(vec3 HSL){
			vec3 RGB = HUEtoRGB(HSL.x);
			float C = (1.0 - abs(2.0 * HSL.z - 1.0)) * HSL.y;
			return (RGB - 0.5) * C + HSL.z;
		}

		void main() {
			vec4 diffuseColor = texture2D( map, vUv );
			gl_FragColor = vec4( diffuseColor.xyz * HSLtoRGB(vec3(vScale/5.0, 1.0, 0.5)), diffuseColor.w );

			if ( diffuseColor.w < 0.5 ) discard;
		}
	</script>

    <script type="importmap">
        {
            "imports": {
                "three": "../build/three.module.js",
                "three/addons/": "./jsm/",
                "three/addons/controls/OrbitControls": "https://threejs.org/examples/jsm/controls/OrbitControls.js"
            }
        }
    </script>

    <script type="module">
	import * as THREE from 'three';
	import Stats from 'three/addons/libs/stats.module.js';
	import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

	let container, stats;
	let camera, scene, renderer, controls;
	let geometry, material, mesh;

	const curves = [];
	const numRows = 1700; // Number of rows of curves
	const particlesPerRow = 10;

	init();

	function init() {
		container = document.createElement('div');
		document.body.appendChild(container);

		camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 50000);
// Position the camera at a specific point
camera.position.set(20394, 5005, 2730);  // Set the x, y, z coordinates for the camera

// Make the camera look at a specific point in the scene
camera.lookAt(new THREE.Vector3(10, 0, 8));  // Make the camera look at the origin or any other point

// Update the camera's projection matrix if necessary
camera.updateProjectionMatrix();

		scene = new THREE.Scene();

		// Create a grid of Bézier curves for the particle river
		for (let i = 0; i < numRows; i++) {
		const yOffset = (i / numRows) * 3 - 1; // Vary the y-position for each row
		const xOffset = (i / numRows) * 2 - 1; // Vary the x-position for each row

		const curve = new THREE.CubicBezierCurve3(
        new THREE.Vector3(-1 + xOffset, yOffset, Math.random() * 0.5 - 0.25), // Start point with xOffset
        new THREE.Vector3(-0.5 + xOffset + Math.random(), yOffset + Math.random(), Math.random()), // Control point 1 with xOffset
        new THREE.Vector3(0.5 + xOffset + Math.random(), yOffset + Math.random(), Math.random()), // Control point 2 with xOffset
        new THREE.Vector3(1 + xOffset, yOffset, Math.random() * 0.5 - 0.25) // End point with xOffset
    );
    
    curves.push(curve);
}
		geometry = new THREE.InstancedBufferGeometry();
		const circleGeometry = new THREE.CircleGeometry(1, 6);
		geometry.index = circleGeometry.index;
		geometry.attributes = circleGeometry.attributes;

		const totalParticles = numRows * particlesPerRow;
		const translateArray = new Float32Array(totalParticles * 3);

		let index = 0;
		for (let i = 0; i < numRows; i++) {
			for (let j = 0; j < particlesPerRow; j++) {
				const t = j / particlesPerRow;
				const position = curves[i].getPoint(t);
				translateArray[index++] = position.x;
				translateArray[index++] = position.y;
				translateArray[index++] = position.z;
			}
		}

		geometry.setAttribute('translate', new THREE.InstancedBufferAttribute(translateArray, 3));

		material = new THREE.RawShaderMaterial({
			uniforms: {
				'map': { value: new THREE.TextureLoader().load('textures/sprites/circle.png') },
				'time': { value: 0.0 }
			},
			vertexShader: document.getElementById('vshader').textContent,
			fragmentShader: document.getElementById('fshader').textContent,
			depthTest: true,
			depthWrite: true
		});

		mesh = new THREE.Mesh(geometry, material);
		mesh.scale.set(50000, 5000, 5000);
		scene.add(mesh);

		renderer = new THREE.WebGLRenderer();
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.setAnimationLoop(animate);
		container.appendChild(renderer.domElement);

		// stats = new Stats();
		// container.appendChild(stats.dom);

		controls = new OrbitControls(camera, renderer.domElement);
		controls.enableDamping = true;
		controls.dampingFactor = 0.05;

		window.addEventListener('resize', onWindowResize);
	}

	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize(window.innerWidth, window.innerHeight);
	}

	function animate() {
		const time = performance.now() * 0.0002;

		const translateArray = geometry.attributes.translate.array;
		let index = 0;

		for (let i = 0; i < numRows; i++) {
			for (let j = 0; j < particlesPerRow; j++) {
				// Update particle positions along the Bézier curve
				const t = (j / particlesPerRow + time * 0.1) % 1;
				const position = curves[i].getPoint(t);
				translateArray[index++] = position.x;
				translateArray[index++] = position.y;
				translateArray[index++] = position.z;
			}
		}

		geometry.attributes.translate.needsUpdate = true;

		material.uniforms['time'].value = time;

		controls.update();
		renderer.render(scene, camera);
		// stats.update();
	}
    </script>
	<script src="index.js"></script>
</body>
</html> 