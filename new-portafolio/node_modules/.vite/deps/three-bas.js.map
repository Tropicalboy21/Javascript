{
  "version": 3,
  "sources": ["../../three-bas/dist/bas.module.js"],
  "sourcesContent": ["import { ShaderMaterial, UniformsUtils, ShaderLib, RGBADepthPacking, BufferGeometry, BufferAttribute, InstancedBufferGeometry, InstancedBufferAttribute, Vector3, MathUtils, Vector4 } from 'three';\n\nclass BaseAnimationMaterial extends ShaderMaterial {\n  constructor (parameters, uniforms) {\n    super();\n\n    if (parameters.uniformValues) {\n      console.warn('THREE.BAS - `uniformValues` is deprecated. Put their values directly into the parameters.');\n\n      Object.keys(parameters.uniformValues).forEach((key) => {\n        parameters[key] = parameters.uniformValues[key];\n      });\n\n      delete parameters.uniformValues;\n    }\n\n    // copy parameters to (1) make use of internal #define generation\n    // and (2) prevent 'x is not a property of this material' warnings.\n    Object.keys(parameters).forEach((key) => {\n      this[key] = parameters[key];\n    });\n\n    // override default parameter values\n    this.setValues(parameters);\n\n    // override uniforms\n    this.uniforms = UniformsUtils.merge([uniforms, parameters.uniforms || {}]);\n\n    // set uniform values from parameters that affect uniforms\n    this.setUniformValues(parameters);\n  }\n\n  setUniformValues (values) {\n    if (!values) return;\n\n    const keys = Object.keys(values);\n\n    keys.forEach((key) => {\n      key in this.uniforms && (this.uniforms[key].value = values[key]);\n    });\n  }\n\n  stringifyChunk (name) {\n    let value;\n\n    if (!this[name]) {\n      value = '';\n    }\n    else if (typeof this[name] ===  'string') {\n      value = this[name];\n    }\n    else {\n      value = this[name].join('\\n');\n    }\n\n    return value;\n  }\n}\n\nclass BasicAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.MeshBasicMaterial with custom shader chunks.\n   *\n   * @see http://three-bas-examples.surge.sh/examples/materials_basic/\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   */\n  constructor (parameters) {\n    super(parameters, ShaderLib['basic'].uniforms);\n\n    this.lights = false;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n\n  concatVertexShader () {\n    return ShaderLib.basic.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <beginnormal_vertex>',\n        `\n        #include <beginnormal_vertex>\n        ${this.stringifyChunk('vertexNormal')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n\n  concatFragmentShader () {\n    return ShaderLib.basic.fragmentShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `\n      )\n      .replace(\n        '#include <map_fragment>',\n        `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${(this.stringifyChunk('fragmentMap') || '#include <map_fragment>')}\n\n        `\n      )\n  }\n}\n\nclass LambertAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.MeshLambertMaterial with custom shader chunks.\n   *\n   * @see http://three-bas-examples.surge.sh/examples/materials_lambert/\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   * @constructor\n   */\n  constructor (parameters) {\n    super(parameters, ShaderLib['lambert'].uniforms);\n\n    this.lights = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n\n  concatVertexShader () {\n    return ShaderLib.lambert.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <beginnormal_vertex>',\n        `\n        #include <beginnormal_vertex>\n\n        ${this.stringifyChunk('vertexNormal')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n\n  concatFragmentShader () {\n    return ShaderLib.lambert.fragmentShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `\n      )\n      .replace(\n        '#include <map_fragment>',\n        `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${(this.stringifyChunk('fragmentMap') || '#include <map_fragment>')}\n\n        `\n      )\n      .replace(\n        '#include <emissivemap_fragment>',\n        `\n        ${this.stringifyChunk('fragmentEmissive')}\n\n        #include <emissivemap_fragment>\n        `\n      )\n  }\n}\n\nclass PhongAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.MeshPhongMaterial with custom shader chunks.\n   *\n   * @see http://three-bas-examples.surge.sh/examples/materials_phong/\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   * @constructor\n   */\n  constructor (parameters) {\n    super(parameters, ShaderLib['phong'].uniforms);\n\n    this.lights = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n\n  concatVertexShader () {\n    return ShaderLib.phong.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <beginnormal_vertex>',\n        `\n        #include <beginnormal_vertex>\n\n        ${this.stringifyChunk('vertexNormal')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n\n  concatFragmentShader () {\n    return ShaderLib.phong.fragmentShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `\n      )\n      .replace(\n        '#include <map_fragment>',\n        `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${(this.stringifyChunk('fragmentMap') || '#include <map_fragment>')}\n\n        `\n      )\n      .replace(\n        '#include <emissivemap_fragment>',\n        `\n        ${this.stringifyChunk('fragmentEmissive')}\n\n        #include <emissivemap_fragment>\n        `\n      )\n      .replace(\n        '#include <lights_phong_fragment>',\n        `\n        #include <lights_phong_fragment>\n        ${this.stringifyChunk('fragmentSpecular')}\n        `\n      )\n  }\n}\n\nclass StandardAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.MeshStandardMaterial with custom shader chunks.\n   *\n   * @see http://three-bas-examples.surge.sh/examples/materials_standard/\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   */\n  constructor (parameters) {\n    super(parameters, ShaderLib['physical'].uniforms);\n\n    this.lights = true;\n    this.extensions = (this.extensions || {});\n    this.extensions.derivatives = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n\n  concatVertexShader () {\n    return ShaderLib.standard.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <beginnormal_vertex>',\n        `\n        #include <beginnormal_vertex>\n\n        ${this.stringifyChunk('vertexNormal')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n\n  concatFragmentShader () {\n    return ShaderLib.standard.fragmentShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `\n      )\n      .replace(\n        '#include <map_fragment>',\n        `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${(this.stringifyChunk('fragmentMap') || '#include <map_fragment>')}\n\n        `\n      )\n      .replace(\n        '#include <emissivemap_fragment>',\n        `\n        ${this.stringifyChunk('fragmentEmissive')}\n\n        #include <emissivemap_fragment>\n        `\n      )\n      .replace(\n        '#include <roughnessmap_fragment>',\n        `\n        float roughnessFactor = roughness;\n        ${this.stringifyChunk('fragmentRoughness')}\n        #ifdef USE_ROUGHNESSMAP\n\n        vec4 texelRoughness = texture2D( roughnessMap, vUv );\n          roughnessFactor *= texelRoughness.g;\n        #endif\n        `\n      )\n      .replace(\n        '#include <metalnessmap_fragment>',\n        `\n        float metalnessFactor = metalness;\n        ${this.stringifyChunk('fragmentMetalness')}\n\n        #ifdef USE_METALNESSMAP\n          vec4 texelMetalness = texture2D( metalnessMap, vUv );\n          metalnessFactor *= texelMetalness.b;\n        #endif\n        `\n      )\n  }\n}\n\nclass ToonAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.MeshToonMaterial with custom shader chunks.\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   */\n  constructor (parameters) {\n    super(parameters, ShaderLib['toon'].uniforms);\n\n    this.lights = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n\n  concatVertexShader () {\n    return ShaderLib.toon.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <beginnormal_vertex>',\n        `\n        #include <beginnormal_vertex>\n\n        ${this.stringifyChunk('vertexNormal')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n\n  concatFragmentShader () {\n    return ShaderLib.toon.fragmentShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `\n      )\n      .replace(\n        '#include <map_fragment>',\n        `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${(this.stringifyChunk('fragmentMap') || '#include <map_fragment>')}\n\n        `\n      )\n      .replace(\n        '#include <emissivemap_fragment>',\n        `\n        ${this.stringifyChunk('fragmentEmissive')}\n\n        #include <emissivemap_fragment>\n        `\n      )\n  }\n}\n\nclass PointsAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.PointsMaterial with custom shader chunks.\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   * @constructor\n   */\n  constructor (parameters) {\n    super(parameters, ShaderLib['points'].uniforms);\n\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n\n  concatVertexShader () {\n    return ShaderLib.points.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n  }\n\n  concatFragmentShader () {\n    return ShaderLib.points.fragmentShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `\n      )\n      .replace(\n        '#include <map_fragment>',\n        `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${(this.stringifyChunk('fragmentMap') || '#include <map_fragment>')}\n\n        `\n      )\n      .replace(\n        '#include <premultiplied_alpha_fragment>',\n        `\n        ${this.stringifyChunk('fragmentShape')}\n\n        #include <premultiplied_alpha_fragment>\n        `\n      )\n  }\n}\n\nclass DepthAnimationMaterial extends BaseAnimationMaterial {\n  constructor (parameters) {\n    super(parameters, ShaderLib['depth'].uniforms);\n\n    this.depthPacking = RGBADepthPacking;\n    this.clipping = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = ShaderLib['depth'].fragmentShader;\n  }\n\n  concatVertexShader () {\n    return ShaderLib.depth.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n}\n\nclass DistanceAnimationMaterial extends BaseAnimationMaterial {\n  constructor (parameters) {\n    super(parameters, ShaderLib['distanceRGBA'].uniforms);\n\n    this.depthPacking = RGBADepthPacking;\n    this.clipping = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = ShaderLib['distanceRGBA'].fragmentShader;\n  }\n\n  concatVertexShader () {\n    return ShaderLib.distanceRGBA.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n}\n\nclass PrefabBufferGeometry extends BufferGeometry {\n  /**\n   * A BufferGeometry where a 'prefab' geometry is repeated a number of times.\n   *\n   * @param {Geometry|BufferGeometry} prefab The Geometry instance to repeat.\n   * @param {Number} count The number of times to repeat the geometry.\n   */\n  constructor (prefab, count) {\n    super();\n\n    /**\n     * A reference to the prefab geometry used to create this instance.\n     * @type {Geometry|BufferGeometry}\n     */\n    this.prefabGeometry = prefab;\n    this.isPrefabBufferGeometry = prefab.isBufferGeometry;\n\n    /**\n     * Number of prefabs.\n     * @type {Number}\n     */\n    this.prefabCount = count;\n\n    /**\n     * Number of vertices of the prefab.\n     * @type {Number}\n     */\n    if (this.isPrefabBufferGeometry) {\n      this.prefabVertexCount = prefab.attributes.position.count;\n    }\n    else {\n      this.prefabVertexCount = prefab.vertices.length;\n    }\n\n    this.bufferIndices();\n    this.bufferPositions();\n  }\n\n  bufferIndices () {\n    let prefabIndices = [];\n    let prefabIndexCount;\n\n    if (this.isPrefabBufferGeometry) {\n      if (this.prefabGeometry.index) {\n        prefabIndexCount = this.prefabGeometry.index.count;\n        prefabIndices = this.prefabGeometry.index.array;\n      }\n      else {\n        prefabIndexCount = this.prefabVertexCount;\n\n        for (let i = 0; i < prefabIndexCount; i++) {\n          prefabIndices.push(i);\n        }\n      }\n    }\n    else {\n      const prefabFaceCount = this.prefabGeometry.faces.length;\n      prefabIndexCount = prefabFaceCount * 3;\n\n      for (let i = 0; i < prefabFaceCount; i++) {\n        const face = this.prefabGeometry.faces[i];\n        prefabIndices.push(face.a, face.b, face.c);\n      }\n    }\n\n    const indexBuffer = new Uint32Array(this.prefabCount * prefabIndexCount);\n\n    this.setIndex(new BufferAttribute(indexBuffer, 1));\n\n    for (let i = 0; i < this.prefabCount; i++) {\n      for (let k = 0; k < prefabIndexCount; k++) {\n        indexBuffer[i * prefabIndexCount + k] = prefabIndices[k] + i * this.prefabVertexCount;\n      }\n    }\n  }\n\n  bufferPositions () {\n    const positionBuffer = this.createAttribute('position', 3).array;\n\n    if (this.isPrefabBufferGeometry) {\n      const positions = this.prefabGeometry.attributes.position.array;\n\n      for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n        for (let j = 0; j < this.prefabVertexCount; j++, offset += 3) {\n          positionBuffer[offset    ] = positions[j * 3];\n          positionBuffer[offset + 1] = positions[j * 3 + 1];\n          positionBuffer[offset + 2] = positions[j * 3 + 2];\n        }\n      }\n    }\n    else {\n      for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n        for (let j = 0; j < this.prefabVertexCount; j++, offset += 3) {\n          const prefabVertex = this.prefabGeometry.vertices[j];\n\n          positionBuffer[offset    ] = prefabVertex.x;\n          positionBuffer[offset + 1] = prefabVertex.y;\n          positionBuffer[offset + 2] = prefabVertex.z;\n        }\n      }\n    }\n  }\n\n  bufferUvs () {\n    const uvBuffer = this.createAttribute('uv', 2).array;\n\n    if (this.isPrefabBufferGeometry) {\n      const uvs = this.prefabGeometry.attributes.uv.array;\n\n      for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n        for (let j = 0; j < this.prefabVertexCount; j++, offset += 2) {\n          uvBuffer[offset    ] = uvs[j * 2];\n          uvBuffer[offset + 1] = uvs[j * 2 + 1];\n        }\n      }\n    } else {\n      const prefabFaceCount = this.prefabGeometry.faces.length;\n      const uvs = [];\n\n      for (let i = 0; i < prefabFaceCount; i++) {\n        const face = this.prefabGeometry.faces[i];\n        const uv = this.prefabGeometry.faceVertexUvs[0][i];\n\n        uvs[face.a] = uv[0];\n        uvs[face.b] = uv[1];\n        uvs[face.c] = uv[2];\n      }\n\n      for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n        for (let j = 0; j < this.prefabVertexCount; j++, offset += 2) {\n          const uv = uvs[j];\n\n          uvBuffer[offset] = uv.x;\n          uvBuffer[offset + 1] = uv.y;\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates a BufferAttribute on this geometry instance.\n   *\n   * @param {String} name Name of the attribute.\n   * @param {Number} itemSize Number of floats per vertex (typically 1, 2, 3 or 4).\n   * @param {function=} factory Function that will be called for each prefab upon creation. Accepts 3 arguments: data[], index and prefabCount. Calls setPrefabData.\n   *\n   * @returns {BufferAttribute}\n   */\n  createAttribute (name, itemSize, factory) {\n    const buffer = new Float32Array(this.prefabCount * this.prefabVertexCount * itemSize);\n    const attribute = new BufferAttribute(buffer, itemSize);\n\n    this.setAttribute(name, attribute);\n\n    if (factory) {\n      const data = [];\n\n      for (let i = 0; i < this.prefabCount; i++) {\n        factory(data, i, this.prefabCount);\n        this.setPrefabData(attribute, i, data);\n      }\n    }\n\n    return attribute;\n  }\n\n  /**\n   * Sets data for all vertices of a prefab at a given index.\n   * Usually called in a loop.\n   *\n   * @param {String|BufferAttribute} attribute The attribute or attribute name where the data is to be stored.\n   * @param {Number} prefabIndex Index of the prefab in the buffer geometry.\n   * @param {Array} data Array of data. Length should be equal to item size of the attribute.\n   */\n  setPrefabData (attribute, prefabIndex, data) {\n    attribute = (typeof attribute === 'string') ? this.attributes[attribute] : attribute;\n\n    let offset = prefabIndex * this.prefabVertexCount * attribute.itemSize;\n\n    for (let i = 0; i < this.prefabVertexCount; i++) {\n      for (let j = 0; j < attribute.itemSize; j++) {\n        attribute.array[offset++] = data[j];\n      }\n    }\n  }\n}\n\nclass MultiPrefabBufferGeometry extends BufferGeometry {\n  /**\n   * A BufferGeometry where a 'prefab' geometry array is repeated a number of times.\n   *\n   * @param {Array} prefabs An array with Geometry instances to repeat.\n   * @param {Number} repeatCount The number of times to repeat the array of Geometries.\n   * @constructor\n   */\n  constructor (prefabs, repeatCount) {\n    super();\n\n    if (Array.isArray(prefabs)) {\n      this.prefabGeometries = prefabs;\n    } else {\n      this.prefabGeometries = [prefabs];\n    }\n\n    this.prefabGeometriesCount = this.prefabGeometries.length;\n\n    /**\n     * Number of prefabs.\n     * @type {Number}\n     */\n    this.prefabCount = repeatCount * this.prefabGeometriesCount;\n    /**\n     * How often the prefab array is repeated.\n     * @type {Number}\n     */\n    this.repeatCount = repeatCount;\n\n    /**\n     * Array of vertex counts per prefab.\n     * @type {Array}\n     */\n    this.prefabVertexCounts = this.prefabGeometries.map(p => p.isBufferGeometry ? p.attributes.position.count : p.vertices.length);\n    /**\n     * Total number of vertices for one repetition of the prefabs\n     * @type {number}\n     */\n    this.repeatVertexCount = this.prefabVertexCounts.reduce((r, v) => r + v, 0);\n\n    this.bufferIndices();\n    this.bufferPositions();\n  }\n\n  bufferIndices () {\n    let repeatIndexCount = 0;\n\n    this.prefabIndices = this.prefabGeometries.map(geometry => {\n      let indices = [];\n\n      if (geometry.isBufferGeometry) {\n        if (geometry.index) {\n          indices = geometry.index.array;\n        } else {\n          for (let i = 0; i < geometry.attributes.position.count; i++) {\n            indices.push(i);\n          }\n        }\n      } else {\n        for (let i = 0; i < geometry.faces.length; i++) {\n          const face = geometry.faces[i];\n          indices.push(face.a, face.b, face.c);\n        }\n      }\n\n      repeatIndexCount += indices.length;\n\n      return indices;\n    });\n\n    const indexBuffer = new Uint32Array(repeatIndexCount * this.repeatCount);\n    let indexOffset = 0;\n    let prefabOffset = 0;\n\n    for (let i = 0; i < this.prefabCount; i++) {\n      const index = i % this.prefabGeometriesCount;\n      const indices = this.prefabIndices[index];\n      const vertexCount = this.prefabVertexCounts[index];\n\n      for (let j = 0; j < indices.length; j++) {\n        indexBuffer[indexOffset++] = indices[j] + prefabOffset;\n      }\n\n      prefabOffset += vertexCount;\n    }\n\n    this.setIndex(new BufferAttribute(indexBuffer, 1));\n  }\n\n  bufferPositions () {\n    const positionBuffer = this.createAttribute('position', 3).array;\n\n    const prefabPositions = this.prefabGeometries.map((geometry, i) => {\n      let positions;\n\n      if (geometry.isBufferGeometry) {\n        positions = geometry.attributes.position.array;\n      } else {\n\n        const vertexCount = this.prefabVertexCounts[i];\n\n        positions = [];\n\n        for (let j = 0, offset = 0; j < vertexCount; j++) {\n          const prefabVertex = geometry.vertices[j];\n\n          positions[offset++] = prefabVertex.x;\n          positions[offset++] = prefabVertex.y;\n          positions[offset++] = prefabVertex.z;\n        }\n      }\n\n      return positions;\n    });\n\n    for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n      const index = i % this.prefabGeometries.length;\n      const vertexCount = this.prefabVertexCounts[index];\n      const positions = prefabPositions[index];\n\n      for (let j = 0; j < vertexCount; j++) {\n        positionBuffer[offset++] = positions[j * 3];\n        positionBuffer[offset++] = positions[j * 3 + 1];\n        positionBuffer[offset++] = positions[j * 3 + 2];\n      }\n    }\n  }\n\n  /**\n   * Creates a BufferAttribute with UV coordinates.\n   */\n  bufferUvs () {\n    const uvBuffer = this.createAttribute('uv', 2).array;\n    const prefabUvs = this.prefabGeometries.map((geometry, i) => {\n      let uvs;\n\n      if (geometry.isBufferGeometry) {\n        if (!geometry.attributes.uv) {\n          console.error('No UV found in prefab geometry', geometry);\n        }\n\n        uvs = geometry.attributes.uv.array;\n      } else {\n        const prefabFaceCount = this.prefabIndices[i].length / 3;\n        const uvObjects = [];\n\n        for (let j = 0; j < prefabFaceCount; j++) {\n          const face = geometry.faces[j];\n          const uv = geometry.faceVertexUvs[0][j];\n\n          uvObjects[face.a] = uv[0];\n          uvObjects[face.b] = uv[1];\n          uvObjects[face.c] = uv[2];\n        }\n\n        uvs = [];\n\n        for (let k = 0; k < uvObjects.length; k++) {\n          uvs[k * 2] = uvObjects[k].x;\n          uvs[k * 2 + 1] = uvObjects[k].y;\n        }\n      }\n\n      return uvs;\n    });\n\n    for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n\n      const index = i % this.prefabGeometries.length;\n      const vertexCount = this.prefabVertexCounts[index];\n      const uvs = prefabUvs[index];\n\n      for (let j = 0; j < vertexCount; j++) {\n        uvBuffer[offset++] = uvs[j * 2];\n        uvBuffer[offset++] = uvs[j * 2 + 1];\n      }\n    }\n  }\n\n  /**\n   * Creates a BufferAttribute on this geometry instance.\n   *\n   * @param {String} name Name of the attribute.\n   * @param {Number} itemSize Number of floats per vertex (typically 1, 2, 3 or 4).\n   * @param {function=} factory Function that will be called for each prefab upon creation. Accepts 3 arguments: data[], index and prefabCount. Calls setPrefabData.\n   *\n   * @returns {BufferAttribute}\n   */\n   createAttribute (name, itemSize, factory) {\n    const buffer = new Float32Array(this.repeatCount * this.repeatVertexCount * itemSize);\n    const attribute = new BufferAttribute(buffer, itemSize);\n\n    this.setAttribute(name, attribute);\n\n    if (factory) {\n      const data = [];\n\n      for (let i = 0; i < this.prefabCount; i++) {\n        factory(data, i, this.prefabCount);\n        this.setPrefabData(attribute, i, data);\n      }\n    }\n\n    return attribute;\n   }\n\n   /**\n   * Sets data for all vertices of a prefab at a given index.\n   * Usually called in a loop.\n   *\n   * @param {String|BufferAttribute} attribute The attribute or attribute name where the data is to be stored.\n   * @param {Number} prefabIndex Index of the prefab in the buffer geometry.\n   * @param {Array} data Array of data. Length should be equal to item size of the attribute.\n   */\n  setPrefabData (attribute, prefabIndex, data) {\n    attribute = (typeof attribute === 'string') ? this.attributes[attribute] : attribute;\n\n    const prefabGeometryIndex = prefabIndex % this.prefabGeometriesCount;\n    const prefabGeometryVertexCount = this.prefabVertexCounts[prefabGeometryIndex];\n    const whole = (prefabIndex / this.prefabGeometriesCount | 0) * this.prefabGeometriesCount;\n    const wholeOffset = whole * this.repeatVertexCount;\n    const part = prefabIndex - whole;\n    let partOffset = 0;\n    let i = 0;\n\n    while(i < part) {\n      partOffset += this.prefabVertexCounts[i++];\n    }\n\n    let offset = (wholeOffset + partOffset) * attribute.itemSize;\n\n    for (let i = 0; i < prefabGeometryVertexCount; i++) {\n      for (let j = 0; j < attribute.itemSize; j++) {\n        attribute.array[offset++] = data[j];\n      }\n    }\n  }\n}\n\nclass InstancedPrefabBufferGeometry extends InstancedBufferGeometry {\n  /**\n   * A wrapper around THREE.InstancedBufferGeometry, which is more memory efficient than PrefabBufferGeometry, but requires the ANGLE_instanced_arrays extension.\n   *\n   * @param {BufferGeometry} prefab The Geometry instance to repeat.\n   * @param {Number} count The number of times to repeat the geometry.\n   */\n  constructor (prefab, count) {\n    super();\n\n    this.prefabGeometry = prefab;\n    this.copy(prefab);\n\n    this.instanceCount = count;\n    this.prefabCount = count;\n  }\n\n  /**\n   * Creates a BufferAttribute on this geometry instance.\n   *\n   * @param {String} name Name of the attribute.\n   * @param {Number} itemSize Number of floats per vertex (typically 1, 2, 3 or 4).\n   * @param {function=} factory Function that will be called for each prefab upon creation. Accepts 3 arguments: data[], index and prefabCount. Calls setPrefabData.\n   *\n   * @returns {BufferAttribute}\n   */\n  createAttribute (name, itemSize, factory) {\n    const buffer = new Float32Array(this.prefabCount * itemSize);\n    const attribute = new InstancedBufferAttribute(buffer, itemSize);\n\n    this.setAttribute(name, attribute);\n\n    if (factory) {\n      const data = [];\n\n      for (let i = 0; i < this.prefabCount; i++) {\n        factory(data, i, this.prefabCount);\n        this.setPrefabData(attribute, i, data);\n      }\n    }\n\n    return attribute;\n  };\n\n  /**\n   * Sets data for a prefab at a given index.\n   * Usually called in a loop.\n   *\n   * @param {String|BufferAttribute} attribute The attribute or attribute name where the data is to be stored.\n   * @param {Number} prefabIndex Index of the prefab in the buffer geometry.\n   * @param {Array} data Array of data. Length should be equal to item size of the attribute.\n   */\n  setPrefabData (attribute, prefabIndex, data) {\n    attribute = (typeof attribute === 'string') ? this.attributes[attribute] : attribute;\n\n    let offset = prefabIndex * attribute.itemSize;\n\n    for (let j = 0; j < attribute.itemSize; j++) {\n      attribute.array[offset++] = data[j];\n    }\n  };\n}\n\n/**\n * Collection of utility functions.\n * @namespace\n */\nconst Utils = {\n  /**\n   * Duplicates vertices so each face becomes separate.\n   * Same as THREE.ExplodeModifier.\n   *\n   * @param {THREE.Geometry} geometry Geometry instance to modify.\n   */\n  separateFaces: function (geometry) {\n    let vertices = [];\n\n    for (let i = 0, il = geometry.faces.length; i < il; i++) {\n      let n = vertices.length;\n      let face = geometry.faces[i];\n\n      let a = face.a;\n      let b = face.b;\n      let c = face.c;\n\n      let va = geometry.vertices[a];\n      let vb = geometry.vertices[b];\n      let vc = geometry.vertices[c];\n\n      vertices.push(va.clone());\n      vertices.push(vb.clone());\n      vertices.push(vc.clone());\n\n      face.a = n;\n      face.b = n + 1;\n      face.c = n + 2;\n    }\n\n    geometry.vertices = vertices;\n  },\n\n  /**\n   * Compute the centroid (center) of a THREE.Face3.\n   *\n   * @param {THREE.Geometry} geometry Geometry instance the face is in.\n   * @param {THREE.Face3} face Face object from the THREE.Geometry.faces array\n   * @param {THREE.Vector3=} v Optional vector to store result in.\n   * @returns {THREE.Vector3}\n   */\n  computeCentroid: function(geometry, face, v) {\n    let a = geometry.vertices[face.a];\n    let b = geometry.vertices[face.b];\n    let c = geometry.vertices[face.c];\n\n    v = v || new Vector3();\n\n    v.x = (a.x + b.x + c.x) / 3;\n    v.y = (a.y + b.y + c.y) / 3;\n    v.z = (a.z + b.z + c.z) / 3;\n\n    return v;\n  },\n\n  /**\n   * Get a random vector between box.min and box.max.\n   *\n   * @param {THREE.Box3} box THREE.Box3 instance.\n   * @param {THREE.Vector3=} v Optional vector to store result in.\n   * @returns {THREE.Vector3}\n   */\n  randomInBox: function(box, v) {\n    v = v || new Vector3();\n\n    v.x = MathUtils.randFloat(box.min.x, box.max.x);\n    v.y = MathUtils.randFloat(box.min.y, box.max.y);\n    v.z = MathUtils.randFloat(box.min.z, box.max.z);\n\n    return v;\n  },\n\n  /**\n   * Get a random axis for quaternion rotation.\n   *\n   * @param {THREE.Vector3=} v Option vector to store result in.\n   * @returns {THREE.Vector3}\n   */\n  randomAxis: function(v) {\n    v = v || new Vector3();\n\n    v.x = MathUtils.randFloatSpread(2.0);\n    v.y = MathUtils.randFloatSpread(2.0);\n    v.z = MathUtils.randFloatSpread(2.0);\n    v.normalize();\n\n    return v;\n  },\n\n  /**\n   * Create a THREE.BAS.DepthAnimationMaterial for shadows from a THREE.SpotLight or THREE.DirectionalLight by copying relevant shader chunks.\n   * Uniform values must be manually synced between the source material and the depth material.\n   *\n   * @see {@link http://three-bas-examples.surge.sh/examples/shadows/}\n   *\n   * @param {THREE.BAS.BaseAnimationMaterial} sourceMaterial Instance to get the shader chunks from.\n   * @returns {THREE.BAS.DepthAnimationMaterial}\n   */\n  createDepthAnimationMaterial: function(sourceMaterial) {\n    return new DepthAnimationMaterial({\n      uniforms: sourceMaterial.uniforms,\n      defines: sourceMaterial.defines,\n      vertexFunctions: sourceMaterial.vertexFunctions,\n      vertexParameters: sourceMaterial.vertexParameters,\n      vertexInit: sourceMaterial.vertexInit,\n      vertexPosition: sourceMaterial.vertexPosition\n    });\n  },\n\n  /**\n   * Create a THREE.BAS.DistanceAnimationMaterial for shadows from a THREE.PointLight by copying relevant shader chunks.\n   * Uniform values must be manually synced between the source material and the distance material.\n   *\n   * @see {@link http://three-bas-examples.surge.sh/examples/shadows/}\n   *\n   * @param {THREE.BAS.BaseAnimationMaterial} sourceMaterial Instance to get the shader chunks from.\n   * @returns {THREE.BAS.DistanceAnimationMaterial}\n   */\n  createDistanceAnimationMaterial: function(sourceMaterial) {\n    return new DistanceAnimationMaterial({\n      uniforms: sourceMaterial.uniforms,\n      defines: sourceMaterial.defines,\n      vertexFunctions: sourceMaterial.vertexFunctions,\n      vertexParameters: sourceMaterial.vertexParameters,\n      vertexInit: sourceMaterial.vertexInit,\n      vertexPosition: sourceMaterial.vertexPosition\n    });\n  }\n};\n\nclass ModelBufferGeometry extends BufferGeometry {\n  /**\n   * A THREE.BufferGeometry for animating individual faces of a THREE.Geometry.\n   *\n   * @param {THREE.Geometry} model The THREE.Geometry to base this geometry on.\n   * @param {Object=} options\n   * @param {Boolean=} options.computeCentroids If true, a centroids will be computed for each face and stored in THREE.BAS.ModelBufferGeometry.centroids.\n   * @param {Boolean=} options.localizeFaces If true, the positions for each face will be stored relative to the centroid. This is useful if you want to rotate or scale faces around their center.\n   */\n  constructor (model, options) {\n    super();\n\n    /**\n     * A reference to the geometry used to create this instance.\n     * @type {THREE.Geometry}\n     */\n    this.modelGeometry = model;\n\n    /**\n     * Number of faces of the model.\n     * @type {Number}\n     */\n    this.faceCount = this.modelGeometry.faces.length;\n\n    /**\n     * Number of vertices of the model.\n     * @type {Number}\n     */\n    this.vertexCount = this.modelGeometry.vertices.length;\n\n    options = options || {};\n    options.computeCentroids && this.computeCentroids();\n\n    this.bufferIndices();\n    this.bufferPositions(options.localizeFaces);\n  }\n\n  /**\n   * Computes a centroid for each face and stores it in THREE.BAS.ModelBufferGeometry.centroids.\n   */\n  computeCentroids () {\n    /**\n     * An array of centroids corresponding to the faces of the model.\n     *\n     * @type {Array}\n     */\n    this.centroids = [];\n\n    for (let i = 0; i < this.faceCount; i++) {\n      this.centroids[i] = Utils.computeCentroid(this.modelGeometry, this.modelGeometry.faces[i]);\n    }\n  }\n\n  bufferIndices () {\n    const indexBuffer = new Uint32Array(this.faceCount * 3);\n\n    this.setIndex(new BufferAttribute(indexBuffer, 1));\n\n    for (let i = 0, offset = 0; i < this.faceCount; i++, offset += 3) {\n      const face = this.modelGeometry.faces[i];\n\n      indexBuffer[offset    ] = face.a;\n      indexBuffer[offset + 1] = face.b;\n      indexBuffer[offset + 2] = face.c;\n    }\n  }\n\n  bufferPositions (localizeFaces) {\n    const positionBuffer = this.createAttribute('position', 3).array;\n    let i, offset;\n\n    if (localizeFaces === true) {\n      for (i = 0; i < this.faceCount; i++) {\n        const face = this.modelGeometry.faces[i];\n        const centroid = this.centroids ? this.centroids[i] : Utils.computeCentroid(this.modelGeometry, face);\n\n        const a = this.modelGeometry.vertices[face.a];\n        const b = this.modelGeometry.vertices[face.b];\n        const c = this.modelGeometry.vertices[face.c];\n\n        positionBuffer[face.a * 3]     = a.x - centroid.x;\n        positionBuffer[face.a * 3 + 1] = a.y - centroid.y;\n        positionBuffer[face.a * 3 + 2] = a.z - centroid.z;\n\n        positionBuffer[face.b * 3]     = b.x - centroid.x;\n        positionBuffer[face.b * 3 + 1] = b.y - centroid.y;\n        positionBuffer[face.b * 3 + 2] = b.z - centroid.z;\n\n        positionBuffer[face.c * 3]     = c.x - centroid.x;\n        positionBuffer[face.c * 3 + 1] = c.y - centroid.y;\n        positionBuffer[face.c * 3 + 2] = c.z - centroid.z;\n      }\n    }\n    else {\n      for (i = 0, offset = 0; i < this.vertexCount; i++, offset += 3) {\n        const vertex = this.modelGeometry.vertices[i];\n\n        positionBuffer[offset    ] = vertex.x;\n        positionBuffer[offset + 1] = vertex.y;\n        positionBuffer[offset + 2] = vertex.z;\n      }\n    }\n  }\n\n  /**\n   * Creates a THREE.BufferAttribute with UV coordinates.\n   */\n  bufferUvs () {\n    const uvBuffer = this.createAttribute('uv', 2).array;\n\n    for (let i = 0; i < this.faceCount; i++) {\n\n      const face = this.modelGeometry.faces[i];\n      let uv;\n\n      uv = this.modelGeometry.faceVertexUvs[0][i][0];\n      uvBuffer[face.a * 2]     = uv.x;\n      uvBuffer[face.a * 2 + 1] = uv.y;\n\n      uv = this.modelGeometry.faceVertexUvs[0][i][1];\n      uvBuffer[face.b * 2]     = uv.x;\n      uvBuffer[face.b * 2 + 1] = uv.y;\n\n      uv = this.modelGeometry.faceVertexUvs[0][i][2];\n      uvBuffer[face.c * 2]     = uv.x;\n      uvBuffer[face.c * 2 + 1] = uv.y;\n    }\n  }\n\n  /**\n   * Creates two THREE.BufferAttributes: skinIndex and skinWeight. Both are required for skinning.\n   */\n  bufferSkinning () {\n    const skinIndexBuffer = this.createAttribute('skinIndex', 4).array;\n    const skinWeightBuffer = this.createAttribute('skinWeight', 4).array;\n\n    for (let i = 0; i < this.vertexCount; i++) {\n      const skinIndex = this.modelGeometry.skinIndices[i];\n      const skinWeight = this.modelGeometry.skinWeights[i];\n\n      skinIndexBuffer[i * 4    ] = skinIndex.x;\n      skinIndexBuffer[i * 4 + 1] = skinIndex.y;\n      skinIndexBuffer[i * 4 + 2] = skinIndex.z;\n      skinIndexBuffer[i * 4 + 3] = skinIndex.w;\n\n      skinWeightBuffer[i * 4    ] = skinWeight.x;\n      skinWeightBuffer[i * 4 + 1] = skinWeight.y;\n      skinWeightBuffer[i * 4 + 2] = skinWeight.z;\n      skinWeightBuffer[i * 4 + 3] = skinWeight.w;\n    }\n  }\n\n  /**\n   * Creates a THREE.BufferAttribute on this geometry instance.\n   *\n   * @param {String} name Name of the attribute.\n   * @param {int} itemSize Number of floats per vertex (typically 1, 2, 3 or 4).\n   * @param {function=} factory Function that will be called for each face upon creation. Accepts 3 arguments: data[], index and faceCount. Calls setFaceData.\n   *\n   * @returns {BufferAttribute}\n   */\n  createAttribute (name, itemSize, factory) {\n    const buffer = new Float32Array(this.vertexCount * itemSize);\n    const attribute = new BufferAttribute(buffer, itemSize);\n\n    this.setAttribute(name, attribute);\n\n    if (factory) {\n      const data = [];\n\n      for (let i = 0; i < this.faceCount; i++) {\n        factory(data, i, this.faceCount);\n        this.setFaceData(attribute, i, data);\n      }\n    }\n\n    return attribute;\n  }\n\n  /**\n   * Sets data for all vertices of a face at a given index.\n   * Usually called in a loop.\n   *\n   * @param {String|THREE.BufferAttribute} attribute The attribute or attribute name where the data is to be stored.\n   * @param {int} faceIndex Index of the face in the buffer geometry.\n   * @param {Array} data Array of data. Length should be equal to item size of the attribute.\n   */\n  setFaceData (attribute, faceIndex, data) {\n    attribute = (typeof attribute === 'string') ? this.attributes[attribute] : attribute;\n\n    let offset = faceIndex * 3 * attribute.itemSize;\n\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < attribute.itemSize; j++) {\n        attribute.array[offset++] = data[j];\n      }\n    }\n  }\n}\n\nclass PointBufferGeometry extends BufferGeometry {\n  /**\n   * A THREE.BufferGeometry consists of points.\n   * @param {Number} count The number of points.\n   * @constructor\n   */\n  constructor (count) {\n    super();\n\n    /**\n     * Number of points.\n     * @type {Number}\n     */\n    this.pointCount = count;\n\n    this.bufferPositions();\n  }\n\n  bufferPositions () {\n    this.createAttribute('position', 3);\n  }\n\n  /**\n   * Creates a THREE.BufferAttribute on this geometry instance.\n   *\n   * @param {String} name Name of the attribute.\n   * @param {Number} itemSize Number of floats per vertex (typically 1, 2, 3 or 4).\n   * @param {function=} factory Function that will be called for each point upon creation. Accepts 3 arguments: data[], index and prefabCount. Calls setPointData.\n   *\n   * @returns {THREE.BufferAttribute}\n   */\n  createAttribute (name, itemSize, factory) {\n    const buffer = new Float32Array(this.pointCount * itemSize);\n    const attribute = new BufferAttribute(buffer, itemSize);\n\n    this.setAttribute(name, attribute);\n\n    if (factory) {\n      const data = [];\n      for (let i = 0; i < this.pointCount; i++) {\n        factory(data, i, this.pointCount);\n        this.setPointData(attribute, i, data);\n      }\n    }\n\n    return attribute;\n  }\n\n  setPointData (attribute, pointIndex, data) {\n    attribute = (typeof attribute === 'string') ? this.attributes[attribute] : attribute;\n\n    let offset = pointIndex * attribute.itemSize;\n\n    for (let j = 0; j < attribute.itemSize; j++) {\n      attribute.array[offset++] = data[j];\n    }\n  }\n}\n\nvar catmull_rom_spline = \"vec4 catmullRomSpline(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t, vec2 c) {\\n    vec4 v0 = (p2 - p0) * c.x;\\n    vec4 v1 = (p3 - p1) * c.y;\\n    float t2 = t * t;\\n    float t3 = t * t * t;\\n    return vec4((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\\n}\\nvec4 catmullRomSpline(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t) {\\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\\n}\\nvec3 catmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t, vec2 c) {\\n    vec3 v0 = (p2 - p0) * c.x;\\n    vec3 v1 = (p3 - p1) * c.y;\\n    float t2 = t * t;\\n    float t3 = t * t * t;\\n    return vec3((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\\n}\\nvec3 catmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t) {\\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\\n}\\nvec2 catmullRomSpline(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t, vec2 c) {\\n    vec2 v0 = (p2 - p0) * c.x;\\n    vec2 v1 = (p3 - p1) * c.y;\\n    float t2 = t * t;\\n    float t3 = t * t * t;\\n    return vec2((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\\n}\\nvec2 catmullRomSpline(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\\n}\\nfloat catmullRomSpline(float p0, float p1, float p2, float p3, float t, vec2 c) {\\n    float v0 = (p2 - p0) * c.x;\\n    float v1 = (p3 - p1) * c.y;\\n    float t2 = t * t;\\n    float t3 = t * t * t;\\n    return float((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\\n}\\nfloat catmullRomSpline(float p0, float p1, float p2, float p3, float t) {\\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\\n}\\nivec4 getCatmullRomSplineIndices(float l, float p) {\\n    float index = floor(p);\\n    int i0 = int(max(0.0, index - 1.0));\\n    int i1 = int(index);\\n    int i2 = int(min(index + 1.0, l));\\n    int i3 = int(min(index + 2.0, l));\\n    return ivec4(i0, i1, i2, i3);\\n}\\nivec4 getCatmullRomSplineIndicesClosed(float l, float p) {\\n    float index = floor(p);\\n    int i0 = int(index == 0.0 ? l : index - 1.0);\\n    int i1 = int(index);\\n    int i2 = int(mod(index + 1.0, l));\\n    int i3 = int(mod(index + 2.0, l));\\n    return ivec4(i0, i1, i2, i3);\\n}\\n\";\n\nvar cubic_bezier = \"vec3 cubicBezier(vec3 p0, vec3 c0, vec3 c1, vec3 p1, float t) {\\n    float tn = 1.0 - t;\\n    return tn * tn * tn * p0 + 3.0 * tn * tn * t * c0 + 3.0 * tn * t * t * c1 + t * t * t * p1;\\n}\\nvec2 cubicBezier(vec2 p0, vec2 c0, vec2 c1, vec2 p1, float t) {\\n    float tn = 1.0 - t;\\n    return tn * tn * tn * p0 + 3.0 * tn * tn * t * c0 + 3.0 * tn * t * t * c1 + t * t * t * p1;\\n}\\n\";\n\nvar ease_back_in = \"float easeBackIn(float p, float amplitude) {\\n    return p * p * ((amplitude + 1.0) * p - amplitude);\\n}\\nfloat easeBackIn(float p) {\\n    return easeBackIn(p, 1.70158);\\n}\\nfloat easeBackIn(float t, float b, float c, float d, float amplitude) {\\n    return b + easeBackIn(t / d, amplitude) * c;\\n}\\nfloat easeBackIn(float t, float b, float c, float d) {\\n    return b + easeBackIn(t / d) * c;\\n}\\n\";\n\nvar ease_back_in_out = \"float easeBackInOut(float p, float amplitude) {\\n    amplitude *= 1.525;\\n    return ((p *= 2.0) < 1.0) ? 0.5 * p * p * ((amplitude + 1.0) * p - amplitude) : 0.5 * ((p -= 2.0) * p * ((amplitude + 1.0) * p + amplitude) + 2.0);\\n}\\nfloat easeBackInOut(float p) {\\n    return easeBackInOut(p, 1.70158);\\n}\\nfloat easeBackInOut(float t, float b, float c, float d, float amplitude) {\\n    return b + easeBackInOut(t / d, amplitude) * c;\\n}\\nfloat easeBackInOut(float t, float b, float c, float d) {\\n    return b + easeBackInOut(t / d) * c;\\n}\\n\";\n\nvar ease_back_out = \"float easeBackOut(float p, float amplitude) {\\n    return ((p = p - 1.0) * p * ((amplitude + 1.0) * p + amplitude) + 1.0);\\n}\\nfloat easeBackOut(float p) {\\n    return easeBackOut(p, 1.70158);\\n}\\nfloat easeBackOut(float t, float b, float c, float d, float amplitude) {\\n    return b + easeBackOut(t / d, amplitude) * c;\\n}\\nfloat easeBackOut(float t, float b, float c, float d) {\\n    return b + easeBackOut(t / d) * c;\\n}\\n\";\n\nvar ease_bezier = \"float easeBezier(float p, vec4 curve) {\\n    float ip = 1.0 - p;\\n    return (3.0 * ip * ip * p * curve.xy + 3.0 * ip * p * p * curve.zw + p * p * p).y;\\n}\\nfloat easeBezier(float t, float b, float c, float d, vec4 curve) {\\n    return b + easeBezier(t / d, curve) * c;\\n}\\n\";\n\nvar ease_bounce_in = \"float easeBounceIn(float p) {\\n    if ((p = 1.0 - p) < 1.0 / 2.75) {\\n        return 1.0 - (7.5625 * p * p);\\n    } else if (p < 2.0 / 2.75) {\\n        return 1.0 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);\\n    } else if (p < 2.5 / 2.75) {\\n        return 1.0 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);\\n    }\\n    return 1.0 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);\\n}\\nfloat easeBounceIn(float t, float b, float c, float d) {\\n    return b + easeBounceIn(t / d) * c;\\n}\\n\";\n\nvar ease_bounce_in_out = \"float easeBounceInOut(float p) {\\n    bool invert = (p < 0.5);\\n    p = invert ? (1.0 - (p * 2.0)) : ((p * 2.0) - 1.0);\\n    if (p < 1.0 / 2.75) {\\n        p = 7.5625 * p * p;\\n    } else if (p < 2.0 / 2.75) {\\n        p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;\\n    } else if (p < 2.5 / 2.75) {\\n        p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;\\n    } else {\\n        p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;\\n    }\\n    return invert ? (1.0 - p) * 0.5 : p * 0.5 + 0.5;\\n}\\nfloat easeBounceInOut(float t, float b, float c, float d) {\\n    return b + easeBounceInOut(t / d) * c;\\n}\\n\";\n\nvar ease_bounce_out = \"float easeBounceOut(float p) {\\n    if (p < 1.0 / 2.75) {\\n        return 7.5625 * p * p;\\n    } else if (p < 2.0 / 2.75) {\\n        return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;\\n    } else if (p < 2.5 / 2.75) {\\n        return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;\\n    }\\n    return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;\\n}\\nfloat easeBounceOut(float t, float b, float c, float d) {\\n    return b + easeBounceOut(t / d) * c;\\n}\\n\";\n\nvar ease_circ_in = \"float easeCircIn(float p) {\\n    return -(sqrt(1.0 - p * p) - 1.0);\\n}\\nfloat easeCircIn(float t, float b, float c, float d) {\\n    return b + easeCircIn(t / d) * c;\\n}\\n\";\n\nvar ease_circ_in_out = \"float easeCircInOut(float p) {\\n    return ((p *= 2.0) < 1.0) ? -0.5 * (sqrt(1.0 - p * p) - 1.0) : 0.5 * (sqrt(1.0 - (p -= 2.0) * p) + 1.0);\\n}\\nfloat easeCircInOut(float t, float b, float c, float d) {\\n    return b + easeCircInOut(t / d) * c;\\n}\\n\";\n\nvar ease_circ_out = \"float easeCircOut(float p) {\\n  return sqrt(1.0 - (p = p - 1.0) * p);\\n}\\nfloat easeCircOut(float t, float b, float c, float d) {\\n  return b + easeCircOut(t / d) * c;\\n}\\n\";\n\nvar ease_cubic_in = \"float easeCubicIn(float t) {\\n  return t * t * t;\\n}\\nfloat easeCubicIn(float t, float b, float c, float d) {\\n  return b + easeCubicIn(t / d) * c;\\n}\\n\";\n\nvar ease_cubic_in_out = \"float easeCubicInOut(float t) {\\n  return (t /= 0.5) < 1.0 ? 0.5 * t * t * t : 0.5 * ((t-=2.0) * t * t + 2.0);\\n}\\nfloat easeCubicInOut(float t, float b, float c, float d) {\\n  return b + easeCubicInOut(t / d) * c;\\n}\\n\";\n\nvar ease_cubic_out = \"float easeCubicOut(float t) {\\n  float f = t - 1.0;\\n  return f * f * f + 1.0;\\n}\\nfloat easeCubicOut(float t, float b, float c, float d) {\\n  return b + easeCubicOut(t / d) * c;\\n}\\n\";\n\nvar ease_elastic_in = \"float easeElasticIn(float p, float amplitude, float period) {\\n    float p1 = max(amplitude, 1.0);\\n    float p2 = period / min(amplitude, 1.0);\\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\\n    return -(p1 * pow(2.0, 10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2));\\n}\\nfloat easeElasticIn(float p) {\\n    return easeElasticIn(p, 1.0, 0.3);\\n}\\nfloat easeElasticIn(float t, float b, float c, float d, float amplitude, float period) {\\n    return b + easeElasticIn(t / d, amplitude, period) * c;\\n}\\nfloat easeElasticIn(float t, float b, float c, float d) {\\n    return b + easeElasticIn(t / d) * c;\\n}\\n\";\n\nvar ease_elastic_in_out = \"float easeElasticInOut(float p, float amplitude, float period) {\\n    float p1 = max(amplitude, 1.0);\\n    float p2 = period / min(amplitude, 1.0);\\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\\n    return ((p *= 2.0) < 1.0) ? -0.5 * (p1 * pow(2.0, 10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2)) : p1 * pow(2.0, -10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2) * 0.5 + 1.0;\\n}\\nfloat easeElasticInOut(float p) {\\n    return easeElasticInOut(p, 1.0, 0.3);\\n}\\nfloat easeElasticInOut(float t, float b, float c, float d, float amplitude, float period) {\\n    return b + easeElasticInOut(t / d, amplitude, period) * c;\\n}\\nfloat easeElasticInOut(float t, float b, float c, float d) {\\n    return b + easeElasticInOut(t / d) * c;\\n}\\n\";\n\nvar ease_elastic_out = \"float easeElasticOut(float p, float amplitude, float period) {\\n    float p1 = max(amplitude, 1.0);\\n    float p2 = period / min(amplitude, 1.0);\\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\\n    return p1 * pow(2.0, -10.0 * p) * sin((p - p3) * PI2 / p2) + 1.0;\\n}\\nfloat easeElasticOut(float p) {\\n    return easeElasticOut(p, 1.0, 0.3);\\n}\\nfloat easeElasticOut(float t, float b, float c, float d, float amplitude, float period) {\\n    return b + easeElasticOut(t / d, amplitude, period) * c;\\n}\\nfloat easeElasticOut(float t, float b, float c, float d) {\\n    return b + easeElasticOut(t / d) * c;\\n}\\n\";\n\nvar ease_expo_in = \"float easeExpoIn(float p) {\\n    return pow(2.0, 10.0 * (p - 1.0));\\n}\\nfloat easeExpoIn(float t, float b, float c, float d) {\\n    return b + easeExpoIn(t / d) * c;\\n}\\n\";\n\nvar ease_expo_in_out = \"float easeExpoInOut(float p) {\\n    return ((p *= 2.0) < 1.0) ? 0.5 * pow(2.0, 10.0 * (p - 1.0)) : 0.5 * (2.0 - pow(2.0, -10.0 * (p - 1.0)));\\n}\\nfloat easeExpoInOut(float t, float b, float c, float d) {\\n    return b + easeExpoInOut(t / d) * c;\\n}\\n\";\n\nvar ease_expo_out = \"float easeExpoOut(float p) {\\n  return 1.0 - pow(2.0, -10.0 * p);\\n}\\nfloat easeExpoOut(float t, float b, float c, float d) {\\n  return b + easeExpoOut(t / d) * c;\\n}\\n\";\n\nvar ease_quad_in = \"float easeQuadIn(float t) {\\n    return t * t;\\n}\\nfloat easeQuadIn(float t, float b, float c, float d) {\\n  return b + easeQuadIn(t / d) * c;\\n}\\n\";\n\nvar ease_quad_in_out = \"float easeQuadInOut(float t) {\\n    float p = 2.0 * t * t;\\n    return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\\n}\\nfloat easeQuadInOut(float t, float b, float c, float d) {\\n    return b + easeQuadInOut(t / d) * c;\\n}\\n\";\n\nvar ease_quad_out = \"float easeQuadOut(float t) {\\n  return -t * (t - 2.0);\\n}\\nfloat easeQuadOut(float t, float b, float c, float d) {\\n  return b + easeQuadOut(t / d) * c;\\n}\\n\";\n\nvar ease_quart_in = \"float easeQuartIn(float t) {\\n  return t * t * t * t;\\n}\\nfloat easeQuartIn(float t, float b, float c, float d) {\\n  return b + easeQuartIn(t / d) * c;\\n}\\n\";\n\nvar ease_quart_in_out = \"float easeQuartInOut(float t) {\\n    return t < 0.5 ? 8.0 * pow(t, 4.0) : -8.0 * pow(t - 1.0, 4.0) + 1.0;\\n}\\nfloat easeQuartInOut(float t, float b, float c, float d) {\\n    return b + easeQuartInOut(t / d) * c;\\n}\\n\";\n\nvar ease_quart_out = \"float easeQuartOut(float t) {\\n  return 1.0 - pow(1.0 - t, 4.0);\\n}\\nfloat easeQuartOut(float t, float b, float c, float d) {\\n  return b + easeQuartOut(t / d) * c;\\n}\\n\";\n\nvar ease_quint_in = \"float easeQuintIn(float t) {\\n    return pow(t, 5.0);\\n}\\nfloat easeQuintIn(float t, float b, float c, float d) {\\n    return b + easeQuintIn(t / d) * c;\\n}\\n\";\n\nvar ease_quint_in_out = \"float easeQuintInOut(float t) {\\n    return (t /= 0.5) < 1.0 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2.0) * t * t * t * t + 2.0);\\n}\\nfloat easeQuintInOut(float t, float b, float c, float d) {\\n    return b + easeQuintInOut(t / d) * c;\\n}\\n\";\n\nvar ease_quint_out = \"float easeQuintOut(float t) {\\n    return (t -= 1.0) * t * t * t * t + 1.0;\\n}\\nfloat easeQuintOut(float t, float b, float c, float d) {\\n    return b + easeQuintOut(t / d) * c;\\n}\\n\";\n\nvar ease_sine_in = \"float easeSineIn(float p) {\\n  return -cos(p * 1.57079632679) + 1.0;\\n}\\nfloat easeSineIn(float t, float b, float c, float d) {\\n  return b + easeSineIn(t / d) * c;\\n}\\n\";\n\nvar ease_sine_in_out = \"float easeSineInOut(float p) {\\n  return -0.5 * (cos(PI * p) - 1.0);\\n}\\nfloat easeSineInOut(float t, float b, float c, float d) {\\n  return b + easeSineInOut(t / d) * c;\\n}\\n\";\n\nvar ease_sine_out = \"float easeSineOut(float p) {\\n  return sin(p * 1.57079632679);\\n}\\nfloat easeSineOut(float t, float b, float c, float d) {\\n  return b + easeSineOut(t / d) * c;\\n}\\n\";\n\nvar quadratic_bezier = \"vec3 quadraticBezier(vec3 p0, vec3 c0, vec3 p1, float t) {\\n    float tn = 1.0 - t;\\n    return tn * tn * p0 + 2.0 * tn * t * c0 + t * t * p1;\\n}\\nvec2 quadraticBezier(vec2 p0, vec2 c0, vec2 p1, float t) {\\n    float tn = 1.0 - t;\\n    return tn * tn * p0 + 2.0 * tn * t * c0 + t * t * p1;\\n}\";\n\nvar quaternion_rotation = \"vec3 rotateVector(vec4 q, vec3 v) {\\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\\n}\\nvec4 quatFromAxisAngle(vec3 axis, float angle) {\\n    float halfAngle = angle * 0.5;\\n    return vec4(axis.xyz * sin(halfAngle), cos(halfAngle));\\n}\\n\";\n\nvar quaternion_slerp = \"vec4 quatSlerp(vec4 q0, vec4 q1, float t) {\\n    float s = 1.0 - t;\\n    float c = dot(q0, q1);\\n    float dir = -1.0;    float sqrSn = 1.0 - c * c;\\n    if (sqrSn > 2.220446049250313e-16) {\\n        float sn = sqrt(sqrSn);\\n        float len = atan(sn, c * dir);\\n        s = sin(s * len) / sn;\\n        t = sin(t * len) / sn;\\n    }\\n    float tDir = t * dir;\\n    return normalize(q0 * s + q1 * tDir);\\n}\\n\";\n\n// generated by scripts/build_shader_chunks.js\n\n\nconst ShaderChunk = {\n  catmull_rom_spline: catmull_rom_spline,\n  cubic_bezier: cubic_bezier,\n  ease_back_in: ease_back_in,\n  ease_back_in_out: ease_back_in_out,\n  ease_back_out: ease_back_out,\n  ease_bezier: ease_bezier,\n  ease_bounce_in: ease_bounce_in,\n  ease_bounce_in_out: ease_bounce_in_out,\n  ease_bounce_out: ease_bounce_out,\n  ease_circ_in: ease_circ_in,\n  ease_circ_in_out: ease_circ_in_out,\n  ease_circ_out: ease_circ_out,\n  ease_cubic_in: ease_cubic_in,\n  ease_cubic_in_out: ease_cubic_in_out,\n  ease_cubic_out: ease_cubic_out,\n  ease_elastic_in: ease_elastic_in,\n  ease_elastic_in_out: ease_elastic_in_out,\n  ease_elastic_out: ease_elastic_out,\n  ease_expo_in: ease_expo_in,\n  ease_expo_in_out: ease_expo_in_out,\n  ease_expo_out: ease_expo_out,\n  ease_quad_in: ease_quad_in,\n  ease_quad_in_out: ease_quad_in_out,\n  ease_quad_out: ease_quad_out,\n  ease_quart_in: ease_quart_in,\n  ease_quart_in_out: ease_quart_in_out,\n  ease_quart_out: ease_quart_out,\n  ease_quint_in: ease_quint_in,\n  ease_quint_in_out: ease_quint_in_out,\n  ease_quint_out: ease_quint_out,\n  ease_sine_in: ease_sine_in,\n  ease_sine_in_out: ease_sine_in_out,\n  ease_sine_out: ease_sine_out,\n  quadratic_bezier: quadratic_bezier,\n  quaternion_rotation: quaternion_rotation,\n  quaternion_slerp: quaternion_slerp,\n\n};\n\n/**\n * A timeline transition segment. An instance of this class is created internally when calling {@link THREE.BAS.Timeline.add}, so you should not use this class directly.\n * The instance is also passed the the compiler function if you register a transition through {@link THREE.BAS.Timeline.register}. There you can use the public properties of the segment to compile the glsl string.\n * @param {string} key A string key generated by the timeline to which this segment belongs. Keys are unique.\n * @param {number} start Start time of this segment in a timeline in seconds.\n * @param {number} duration Duration of this segment in seconds.\n * @param {object} transition Object describing the transition.\n * @param {function} compiler A reference to the compiler function from a transition definition.\n * @constructor\n */\nfunction TimelineSegment(key, start, duration, transition, compiler) {\n  this.key = key;\n  this.start = start;\n  this.duration = duration;\n  this.transition = transition;\n  this.compiler = compiler;\n\n  this.trail = 0;\n}\n\nTimelineSegment.prototype.compile = function() {\n  return this.compiler(this);\n};\n\nObject.defineProperty(TimelineSegment.prototype, 'end', {\n  get: function() {\n    return this.start + this.duration;\n  }\n});\n\n/**\n * A utility class to create an animation timeline which can be baked into a (vertex) shader.\n * By default the timeline supports translation, scale and rotation. This can be extended or overridden.\n * @constructor\n */\nfunction Timeline() {\n  /**\n   * The total duration of the timeline in seconds.\n   * @type {number}\n   */\n  this.duration = 0;\n\n  /**\n   * The name of the value that segments will use to read the time. Defaults to 'tTime'.\n   * @type {string}\n   */\n  this.timeKey = 'tTime';\n\n  this.segments = {};\n  this.__key = 0;\n}\n\n// static definitions map\nTimeline.segmentDefinitions = {};\n\n/**\n * Registers a transition definition for use with {@link THREE.BAS.Timeline.add}.\n * @param {String} key Name of the transition. Defaults include 'scale', 'rotate' and 'translate'.\n * @param {Object} definition\n * @param {Function} definition.compiler A function that generates a glsl string for a transition segment. Accepts a THREE.BAS.TimelineSegment as the sole argument.\n * @param {*} definition.defaultFrom The initial value for a transform.from. For example, the defaultFrom for a translation is THREE.Vector3(0, 0, 0).\n * @static\n */\nTimeline.register = function(key, definition) {\n  Timeline.segmentDefinitions[key] = definition;\n  \n  return definition;\n};\n\n/**\n * Add a transition to the timeline.\n * @param {number} duration Duration in seconds\n * @param {object} transitions An object containing one or several transitions. The keys should match transform definitions.\n * The transition object for each key will be passed to the matching definition's compiler. It can have arbitrary properties, but the Timeline expects at least a 'to', 'from' and an optional 'ease'.\n * @param {number|string} [positionOffset] Position in the timeline. Defaults to the end of the timeline. If a number is provided, the transition will be inserted at that time in seconds. Strings ('+=x' or '-=x') can be used for a value relative to the end of timeline.\n */\nTimeline.prototype.add = function(duration, transitions, positionOffset) {\n  // stop rollup from complaining about eval\n  const _eval = eval;\n  \n  let start = this.duration;\n\n  if (positionOffset !== undefined) {\n    if (typeof positionOffset === 'number') {\n      start = positionOffset;\n    }\n    else if (typeof positionOffset === 'string') {\n      _eval('start' + positionOffset);\n    }\n\n    this.duration = Math.max(this.duration, start + duration);\n  }\n  else {\n    this.duration += duration;\n  }\n\n  let keys = Object.keys(transitions), key;\n\n  for (let i = 0; i < keys.length; i++) {\n    key = keys[i];\n\n    this.processTransition(key, transitions[key], start, duration);\n  }\n};\n\nTimeline.prototype.processTransition = function(key, transition, start, duration) {\n  const definition = Timeline.segmentDefinitions[key];\n\n  let segments = this.segments[key];\n  if (!segments) segments = this.segments[key] = [];\n\n  if (transition.from === undefined) {\n    if (segments.length === 0) {\n      transition.from = definition.defaultFrom;\n    }\n    else {\n      transition.from = segments[segments.length - 1].transition.to;\n    }\n  }\n\n  segments.push(new TimelineSegment((this.__key++).toString(), start, duration, transition, definition.compiler));\n};\n\n/**\n * Compiles the timeline into a glsl string array that can be injected into a (vertex) shader.\n * @returns {Array}\n */\nTimeline.prototype.compile = function() {\n  const c = [];\n\n  const keys = Object.keys(this.segments);\n  let segments;\n\n  for (let i = 0; i < keys.length; i++) {\n    segments = this.segments[keys[i]];\n\n    this.fillGaps(segments);\n\n    segments.forEach(function(s) {\n      c.push(s.compile());\n    });\n  }\n\n  return c;\n};\nTimeline.prototype.fillGaps = function(segments) {\n  if (segments.length === 0) return;\n\n  let s0, s1;\n\n  for (let i = 0; i < segments.length - 1; i++) {\n    s0 = segments[i];\n    s1 = segments[i + 1];\n\n    s0.trail = s1.start - s0.end;\n  }\n\n  // pad last segment until end of timeline\n  s0 = segments[segments.length - 1];\n  s0.trail = this.duration - s0.end;\n};\n\n/**\n * Get a compiled glsl string with calls to transform functions for a given key.\n * The order in which these transitions are applied matters because they all operate on the same value.\n * @param {string} key A key matching a transform definition.\n * @returns {string}\n */\nTimeline.prototype.getTransformCalls = function(key) {\n  let t = this.timeKey;\n\n  return this.segments[key] ?  this.segments[key].map(function(s) {\n    return `applyTransform${s.key}(${t}, transformed);`;\n  }).join('\\n') : '';\n};\n\nconst TimelineChunks = {\n  vec3: function(n, v, p) {\n    const x = (v.x || 0).toPrecision(p);\n    const y = (v.y || 0).toPrecision(p);\n    const z = (v.z || 0).toPrecision(p);\n\n    return `vec3 ${n} = vec3(${x}, ${y}, ${z});`;\n  },\n  vec4: function(n, v, p) {\n    const x = (v.x || 0).toPrecision(p);\n    const y = (v.y || 0).toPrecision(p);\n    const z = (v.z || 0).toPrecision(p);\n    const w = (v.w || 0).toPrecision(p);\n  \n    return `vec4 ${n} = vec4(${x}, ${y}, ${z}, ${w});`;\n  },\n  delayDuration: function(segment) {\n    return `\n    float cDelay${segment.key} = ${segment.start.toPrecision(4)};\n    float cDuration${segment.key} = ${segment.duration.toPrecision(4)};\n    `;\n  },\n  progress: function(segment) {\n    // zero duration segments should always render complete\n    if (segment.duration === 0) {\n      return `float progress = 1.0;`\n    }\n    else {\n      return `\n      float progress = clamp(time - cDelay${segment.key}, 0.0, cDuration${segment.key}) / cDuration${segment.key};\n      ${segment.transition.ease ? `progress = ${segment.transition.ease}(progress${(segment.transition.easeParams ? `, ${segment.transition.easeParams.map((v) => v.toPrecision(4)).join(`, `)}` : ``)});` : ``}\n      `;\n    }\n  },\n  renderCheck: function(segment) {\n    const startTime = segment.start.toPrecision(4);\n    const endTime = (segment.end + segment.trail).toPrecision(4);\n\n    return `if (time < ${startTime} || time > ${endTime}) return;`;\n  }\n};\n\nconst TranslationSegment = {\n  compiler: function(segment) {\n    return `\n    ${TimelineChunks.delayDuration(segment)}\n    ${TimelineChunks.vec3(`cTranslateFrom${segment.key}`, segment.transition.from, 2)}\n    ${TimelineChunks.vec3(`cTranslateTo${segment.key}`, segment.transition.to, 2)}\n    \n    void applyTransform${segment.key}(float time, inout vec3 v) {\n    \n      ${TimelineChunks.renderCheck(segment)}\n      ${TimelineChunks.progress(segment)}\n    \n      v += mix(cTranslateFrom${segment.key}, cTranslateTo${segment.key}, progress);\n    }\n    `;\n  },\n  defaultFrom: new Vector3(0, 0, 0)\n};\n\nTimeline.register('translate', TranslationSegment);\n\nconst ScaleSegment = {\n  compiler: function(segment) {\n    const origin = segment.transition.origin;\n    \n    return `\n    ${TimelineChunks.delayDuration(segment)}\n    ${TimelineChunks.vec3(`cScaleFrom${segment.key}`, segment.transition.from, 2)}\n    ${TimelineChunks.vec3(`cScaleTo${segment.key}`, segment.transition.to, 2)}\n    ${origin ? TimelineChunks.vec3(`cOrigin${segment.key}`, origin, 2) : ''}\n    \n    void applyTransform${segment.key}(float time, inout vec3 v) {\n    \n      ${TimelineChunks.renderCheck(segment)}\n      ${TimelineChunks.progress(segment)}\n    \n      ${origin ? `v -= cOrigin${segment.key};` : ''}\n      v *= mix(cScaleFrom${segment.key}, cScaleTo${segment.key}, progress);\n      ${origin ? `v += cOrigin${segment.key};` : ''}\n    }\n    `;\n  },\n  defaultFrom: new Vector3(1, 1, 1)\n};\n\nTimeline.register('scale', ScaleSegment);\n\nconst RotationSegment = {\n  compiler(segment) {\n    const fromAxisAngle = new Vector4(\n      segment.transition.from.axis.x,\n      segment.transition.from.axis.y,\n      segment.transition.from.axis.z,\n      segment.transition.from.angle\n    );\n  \n    const toAxis = segment.transition.to.axis || segment.transition.from.axis;\n    const toAxisAngle = new Vector4(\n      toAxis.x,\n      toAxis.y,\n      toAxis.z,\n      segment.transition.to.angle\n    );\n  \n    const origin = segment.transition.origin;\n    \n    return `\n    ${TimelineChunks.delayDuration(segment)}\n    ${TimelineChunks.vec4(`cRotationFrom${segment.key}`, fromAxisAngle, 8)}\n    ${TimelineChunks.vec4(`cRotationTo${segment.key}`, toAxisAngle, 8)}\n    ${origin ? TimelineChunks.vec3(`cOrigin${segment.key}`, origin, 2) : ''}\n    \n    void applyTransform${segment.key}(float time, inout vec3 v) {\n      ${TimelineChunks.renderCheck(segment)}\n      ${TimelineChunks.progress(segment)}\n\n      ${origin ? `v -= cOrigin${segment.key};` : ''}\n      vec3 axis = normalize(mix(cRotationFrom${segment.key}.xyz, cRotationTo${segment.key}.xyz, progress));\n      float angle = mix(cRotationFrom${segment.key}.w, cRotationTo${segment.key}.w, progress);\n      vec4 q = quatFromAxisAngle(axis, angle);\n      v = rotateVector(q, v);\n      ${origin ? `v += cOrigin${segment.key};` : ''}\n    }\n    `;\n  },\n  defaultFrom: {axis: new Vector3(), angle: 0}\n};\n\nTimeline.register('rotate', RotationSegment);\n\nexport { BaseAnimationMaterial, BasicAnimationMaterial, DepthAnimationMaterial, DistanceAnimationMaterial, InstancedPrefabBufferGeometry, LambertAnimationMaterial, ModelBufferGeometry, MultiPrefabBufferGeometry, PhongAnimationMaterial, PointBufferGeometry, PointsAnimationMaterial, PrefabBufferGeometry, RotationSegment, ScaleSegment, ShaderChunk, StandardAnimationMaterial, Timeline, TimelineChunks, TimelineSegment, ToonAnimationMaterial, TranslationSegment, Utils };\n"],
  "mappings": ";;;;;;;;;;;;;;;AAEA,IAAM,wBAAN,cAAoC,eAAe;AAAA,EACjD,YAAa,YAAY,UAAU;AACjC,UAAM;AAEN,QAAI,WAAW,eAAe;AAC5B,cAAQ,KAAK,2FAA2F;AAExG,aAAO,KAAK,WAAW,aAAa,EAAE,QAAQ,CAAC,QAAQ;AACrD,mBAAW,GAAG,IAAI,WAAW,cAAc,GAAG;AAAA,MAChD,CAAC;AAED,aAAO,WAAW;AAAA,IACpB;AAIA,WAAO,KAAK,UAAU,EAAE,QAAQ,CAAC,QAAQ;AACvC,WAAK,GAAG,IAAI,WAAW,GAAG;AAAA,IAC5B,CAAC;AAGD,SAAK,UAAU,UAAU;AAGzB,SAAK,WAAW,cAAc,MAAM,CAAC,UAAU,WAAW,YAAY,CAAC,CAAC,CAAC;AAGzE,SAAK,iBAAiB,UAAU;AAAA,EAClC;AAAA,EAEA,iBAAkB,QAAQ;AACxB,QAAI,CAAC,OAAQ;AAEb,UAAM,OAAO,OAAO,KAAK,MAAM;AAE/B,SAAK,QAAQ,CAAC,QAAQ;AACpB,aAAO,KAAK,aAAa,KAAK,SAAS,GAAG,EAAE,QAAQ,OAAO,GAAG;AAAA,IAChE,CAAC;AAAA,EACH;AAAA,EAEA,eAAgB,MAAM;AACpB,QAAI;AAEJ,QAAI,CAAC,KAAK,IAAI,GAAG;AACf,cAAQ;AAAA,IACV,WACS,OAAO,KAAK,IAAI,MAAO,UAAU;AACxC,cAAQ,KAAK,IAAI;AAAA,IACnB,OACK;AACH,cAAQ,KAAK,IAAI,EAAE,KAAK,IAAI;AAAA,IAC9B;AAEA,WAAO;AAAA,EACT;AACF;AAEA,IAAM,yBAAN,cAAqC,sBAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQzD,YAAa,YAAY;AACvB,UAAM,YAAY,UAAU,OAAO,EAAE,QAAQ;AAE7C,SAAK,SAAS;AACd,SAAK,eAAe,KAAK,mBAAmB;AAC5C,SAAK,iBAAiB,KAAK,qBAAqB;AAAA,EAClD;AAAA,EAEA,qBAAsB;AACpB,WAAO,UAAU,MAAM,aACpB;AAAA,MACC;AAAA,MACA;AAAA,UACE,KAAK,eAAe,kBAAkB,CAAC;AAAA,UACvC,KAAK,eAAe,mBAAmB,CAAC;AAAA,UACxC,KAAK,eAAe,iBAAiB,CAAC;AAAA;AAAA;AAAA,YAGpC,KAAK,eAAe,YAAY,CAAC;AAAA;AAAA,IAEvC,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA,UAEE,KAAK,eAAe,cAAc,CAAC;AAAA;AAAA,IAEvC,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA,UAEE,KAAK,eAAe,gBAAgB,CAAC;AAAA,UACrC,KAAK,eAAe,aAAa,CAAC;AAAA;AAAA,IAEtC,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA,UAEE,KAAK,eAAe,iBAAiB,CAAC;AAAA;AAAA,IAE1C,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA,UAEE,KAAK,eAAe,oBAAoB,CAAC;AAAA;AAAA,IAE7C;AAAA,EACJ;AAAA,EAEA,uBAAwB;AACtB,WAAO,UAAU,MAAM,eACpB;AAAA,MACC;AAAA,MACA;AAAA,UACE,KAAK,eAAe,oBAAoB,CAAC;AAAA,UACzC,KAAK,eAAe,mBAAmB,CAAC;AAAA,UACxC,KAAK,eAAe,mBAAmB,CAAC;AAAA;AAAA;AAAA,YAGtC,KAAK,eAAe,cAAc,CAAC;AAAA;AAAA,IAEzC,EACC;AAAA,MACC;AAAA,MACA;AAAA,UACE,KAAK,eAAe,iBAAiB,CAAC;AAAA,UACrC,KAAK,eAAe,aAAa,KAAK,yBAA0B;AAAA;AAAA;AAAA,IAGrE;AAAA,EACJ;AACF;AAEA,IAAM,2BAAN,cAAuC,sBAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAS3D,YAAa,YAAY;AACvB,UAAM,YAAY,UAAU,SAAS,EAAE,QAAQ;AAE/C,SAAK,SAAS;AACd,SAAK,eAAe,KAAK,mBAAmB;AAC5C,SAAK,iBAAiB,KAAK,qBAAqB;AAAA,EAClD;AAAA,EAEA,qBAAsB;AACpB,WAAO,UAAU,QAAQ,aACtB;AAAA,MACC;AAAA,MACA;AAAA,UACE,KAAK,eAAe,kBAAkB,CAAC;AAAA,UACvC,KAAK,eAAe,mBAAmB,CAAC;AAAA,UACxC,KAAK,eAAe,iBAAiB,CAAC;AAAA;AAAA;AAAA,YAGpC,KAAK,eAAe,YAAY,CAAC;AAAA;AAAA,IAEvC,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA;AAAA,UAGE,KAAK,eAAe,cAAc,CAAC;AAAA;AAAA,IAEvC,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA;AAAA,UAGE,KAAK,eAAe,gBAAgB,CAAC;AAAA,UACrC,KAAK,eAAe,aAAa,CAAC;AAAA;AAAA,IAEtC,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA;AAAA,UAGE,KAAK,eAAe,iBAAiB,CAAC;AAAA;AAAA,IAE1C,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA;AAAA,UAGE,KAAK,eAAe,oBAAoB,CAAC;AAAA;AAAA,IAE7C;AAAA,EACJ;AAAA,EAEA,uBAAwB;AACtB,WAAO,UAAU,QAAQ,eACtB;AAAA,MACC;AAAA,MACA;AAAA,UACE,KAAK,eAAe,oBAAoB,CAAC;AAAA,UACzC,KAAK,eAAe,mBAAmB,CAAC;AAAA,UACxC,KAAK,eAAe,mBAAmB,CAAC;AAAA;AAAA;AAAA,YAGtC,KAAK,eAAe,cAAc,CAAC;AAAA;AAAA,IAEzC,EACC;AAAA,MACC;AAAA,MACA;AAAA,UACE,KAAK,eAAe,iBAAiB,CAAC;AAAA,UACrC,KAAK,eAAe,aAAa,KAAK,yBAA0B;AAAA;AAAA;AAAA,IAGrE,EACC;AAAA,MACC;AAAA,MACA;AAAA,UACE,KAAK,eAAe,kBAAkB,CAAC;AAAA;AAAA;AAAA;AAAA,IAI3C;AAAA,EACJ;AACF;AAEA,IAAM,yBAAN,cAAqC,sBAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASzD,YAAa,YAAY;AACvB,UAAM,YAAY,UAAU,OAAO,EAAE,QAAQ;AAE7C,SAAK,SAAS;AACd,SAAK,eAAe,KAAK,mBAAmB;AAC5C,SAAK,iBAAiB,KAAK,qBAAqB;AAAA,EAClD;AAAA,EAEA,qBAAsB;AACpB,WAAO,UAAU,MAAM,aACpB;AAAA,MACC;AAAA,MACA;AAAA,UACE,KAAK,eAAe,kBAAkB,CAAC;AAAA,UACvC,KAAK,eAAe,mBAAmB,CAAC;AAAA,UACxC,KAAK,eAAe,iBAAiB,CAAC;AAAA;AAAA;AAAA,YAGpC,KAAK,eAAe,YAAY,CAAC;AAAA;AAAA,IAEvC,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA;AAAA,UAGE,KAAK,eAAe,cAAc,CAAC;AAAA;AAAA,IAEvC,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA;AAAA,UAGE,KAAK,eAAe,gBAAgB,CAAC;AAAA,UACrC,KAAK,eAAe,aAAa,CAAC;AAAA;AAAA,IAEtC,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA;AAAA,UAGE,KAAK,eAAe,iBAAiB,CAAC;AAAA;AAAA,IAE1C,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA;AAAA,UAGE,KAAK,eAAe,oBAAoB,CAAC;AAAA;AAAA,IAE7C;AAAA,EACJ;AAAA,EAEA,uBAAwB;AACtB,WAAO,UAAU,MAAM,eACpB;AAAA,MACC;AAAA,MACA;AAAA,UACE,KAAK,eAAe,oBAAoB,CAAC;AAAA,UACzC,KAAK,eAAe,mBAAmB,CAAC;AAAA,UACxC,KAAK,eAAe,mBAAmB,CAAC;AAAA;AAAA;AAAA,YAGtC,KAAK,eAAe,cAAc,CAAC;AAAA;AAAA,IAEzC,EACC;AAAA,MACC;AAAA,MACA;AAAA,UACE,KAAK,eAAe,iBAAiB,CAAC;AAAA,UACrC,KAAK,eAAe,aAAa,KAAK,yBAA0B;AAAA;AAAA;AAAA,IAGrE,EACC;AAAA,MACC;AAAA,MACA;AAAA,UACE,KAAK,eAAe,kBAAkB,CAAC;AAAA;AAAA;AAAA;AAAA,IAI3C,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA,UAEE,KAAK,eAAe,kBAAkB,CAAC;AAAA;AAAA,IAE3C;AAAA,EACJ;AACF;AAEA,IAAM,4BAAN,cAAwC,sBAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQ5D,YAAa,YAAY;AACvB,UAAM,YAAY,UAAU,UAAU,EAAE,QAAQ;AAEhD,SAAK,SAAS;AACd,SAAK,aAAc,KAAK,cAAc,CAAC;AACvC,SAAK,WAAW,cAAc;AAC9B,SAAK,eAAe,KAAK,mBAAmB;AAC5C,SAAK,iBAAiB,KAAK,qBAAqB;AAAA,EAClD;AAAA,EAEA,qBAAsB;AACpB,WAAO,UAAU,SAAS,aACvB;AAAA,MACC;AAAA,MACA;AAAA,UACE,KAAK,eAAe,kBAAkB,CAAC;AAAA,UACvC,KAAK,eAAe,mBAAmB,CAAC;AAAA,UACxC,KAAK,eAAe,iBAAiB,CAAC;AAAA;AAAA;AAAA,YAGpC,KAAK,eAAe,YAAY,CAAC;AAAA;AAAA,IAEvC,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA;AAAA,UAGE,KAAK,eAAe,cAAc,CAAC;AAAA;AAAA,IAEvC,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA;AAAA,UAGE,KAAK,eAAe,gBAAgB,CAAC;AAAA,UACrC,KAAK,eAAe,aAAa,CAAC;AAAA;AAAA,IAEtC,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA;AAAA,UAGE,KAAK,eAAe,iBAAiB,CAAC;AAAA;AAAA,IAE1C,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA;AAAA,UAGE,KAAK,eAAe,oBAAoB,CAAC;AAAA;AAAA,IAE7C;AAAA,EACJ;AAAA,EAEA,uBAAwB;AACtB,WAAO,UAAU,SAAS,eACvB;AAAA,MACC;AAAA,MACA;AAAA,UACE,KAAK,eAAe,oBAAoB,CAAC;AAAA,UACzC,KAAK,eAAe,mBAAmB,CAAC;AAAA,UACxC,KAAK,eAAe,mBAAmB,CAAC;AAAA;AAAA;AAAA,YAGtC,KAAK,eAAe,cAAc,CAAC;AAAA;AAAA,IAEzC,EACC;AAAA,MACC;AAAA,MACA;AAAA,UACE,KAAK,eAAe,iBAAiB,CAAC;AAAA,UACrC,KAAK,eAAe,aAAa,KAAK,yBAA0B;AAAA;AAAA;AAAA,IAGrE,EACC;AAAA,MACC;AAAA,MACA;AAAA,UACE,KAAK,eAAe,kBAAkB,CAAC;AAAA;AAAA;AAAA;AAAA,IAI3C,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA,UAEE,KAAK,eAAe,mBAAmB,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAO5C,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA,UAEE,KAAK,eAAe,mBAAmB,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAO5C;AAAA,EACJ;AACF;AAEA,IAAM,wBAAN,cAAoC,sBAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMxD,YAAa,YAAY;AACvB,UAAM,YAAY,UAAU,MAAM,EAAE,QAAQ;AAE5C,SAAK,SAAS;AACd,SAAK,eAAe,KAAK,mBAAmB;AAC5C,SAAK,iBAAiB,KAAK,qBAAqB;AAAA,EAClD;AAAA,EAEA,qBAAsB;AACpB,WAAO,UAAU,KAAK,aACnB;AAAA,MACC;AAAA,MACA;AAAA,UACE,KAAK,eAAe,kBAAkB,CAAC;AAAA,UACvC,KAAK,eAAe,mBAAmB,CAAC;AAAA,UACxC,KAAK,eAAe,iBAAiB,CAAC;AAAA;AAAA;AAAA,YAGpC,KAAK,eAAe,YAAY,CAAC;AAAA;AAAA,IAEvC,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA;AAAA,UAGE,KAAK,eAAe,cAAc,CAAC;AAAA;AAAA,IAEvC,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA;AAAA,UAGE,KAAK,eAAe,gBAAgB,CAAC;AAAA,UACrC,KAAK,eAAe,aAAa,CAAC;AAAA;AAAA,IAEtC,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA;AAAA,UAGE,KAAK,eAAe,iBAAiB,CAAC;AAAA;AAAA,IAE1C,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA;AAAA,UAGE,KAAK,eAAe,oBAAoB,CAAC;AAAA;AAAA,IAE7C;AAAA,EACJ;AAAA,EAEA,uBAAwB;AACtB,WAAO,UAAU,KAAK,eACnB;AAAA,MACC;AAAA,MACA;AAAA,UACE,KAAK,eAAe,oBAAoB,CAAC;AAAA,UACzC,KAAK,eAAe,mBAAmB,CAAC;AAAA,UACxC,KAAK,eAAe,mBAAmB,CAAC;AAAA;AAAA;AAAA,YAGtC,KAAK,eAAe,cAAc,CAAC;AAAA;AAAA,IAEzC,EACC;AAAA,MACC;AAAA,MACA;AAAA,UACE,KAAK,eAAe,iBAAiB,CAAC;AAAA,UACrC,KAAK,eAAe,aAAa,KAAK,yBAA0B;AAAA;AAAA;AAAA,IAGrE,EACC;AAAA,MACC;AAAA,MACA;AAAA,UACE,KAAK,eAAe,kBAAkB,CAAC;AAAA;AAAA;AAAA;AAAA,IAI3C;AAAA,EACJ;AACF;AAEA,IAAM,0BAAN,cAAsC,sBAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAO1D,YAAa,YAAY;AACvB,UAAM,YAAY,UAAU,QAAQ,EAAE,QAAQ;AAE9C,SAAK,eAAe,KAAK,mBAAmB;AAC5C,SAAK,iBAAiB,KAAK,qBAAqB;AAAA,EAClD;AAAA,EAEA,qBAAsB;AACpB,WAAO,UAAU,OAAO,aACrB;AAAA,MACC;AAAA,MACA;AAAA,UACE,KAAK,eAAe,kBAAkB,CAAC;AAAA,UACvC,KAAK,eAAe,mBAAmB,CAAC;AAAA,UACxC,KAAK,eAAe,iBAAiB,CAAC;AAAA;AAAA;AAAA,YAGpC,KAAK,eAAe,YAAY,CAAC;AAAA;AAAA,IAEvC,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA;AAAA,UAGE,KAAK,eAAe,gBAAgB,CAAC;AAAA,UACrC,KAAK,eAAe,aAAa,CAAC;AAAA;AAAA,IAEtC,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA;AAAA,UAGE,KAAK,eAAe,iBAAiB,CAAC;AAAA;AAAA,IAE1C;AAAA,EACJ;AAAA,EAEA,uBAAwB;AACtB,WAAO,UAAU,OAAO,eACrB;AAAA,MACC;AAAA,MACA;AAAA,UACE,KAAK,eAAe,oBAAoB,CAAC;AAAA,UACzC,KAAK,eAAe,mBAAmB,CAAC;AAAA,UACxC,KAAK,eAAe,mBAAmB,CAAC;AAAA;AAAA;AAAA,YAGtC,KAAK,eAAe,cAAc,CAAC;AAAA;AAAA,IAEzC,EACC;AAAA,MACC;AAAA,MACA;AAAA,UACE,KAAK,eAAe,iBAAiB,CAAC;AAAA,UACrC,KAAK,eAAe,aAAa,KAAK,yBAA0B;AAAA;AAAA;AAAA,IAGrE,EACC;AAAA,MACC;AAAA,MACA;AAAA,UACE,KAAK,eAAe,eAAe,CAAC;AAAA;AAAA;AAAA;AAAA,IAIxC;AAAA,EACJ;AACF;AAEA,IAAM,yBAAN,cAAqC,sBAAsB;AAAA,EACzD,YAAa,YAAY;AACvB,UAAM,YAAY,UAAU,OAAO,EAAE,QAAQ;AAE7C,SAAK,eAAe;AACpB,SAAK,WAAW;AAChB,SAAK,eAAe,KAAK,mBAAmB;AAC5C,SAAK,iBAAiB,UAAU,OAAO,EAAE;AAAA,EAC3C;AAAA,EAEA,qBAAsB;AACpB,WAAO,UAAU,MAAM,aACpB;AAAA,MACC;AAAA,MACA;AAAA,UACE,KAAK,eAAe,kBAAkB,CAAC;AAAA,UACvC,KAAK,eAAe,iBAAiB,CAAC;AAAA;AAAA;AAAA,YAGpC,KAAK,eAAe,YAAY,CAAC;AAAA;AAAA,IAEvC,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA;AAAA,UAGE,KAAK,eAAe,gBAAgB,CAAC;AAAA;AAAA,IAEzC,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA;AAAA,UAGE,KAAK,eAAe,iBAAiB,CAAC;AAAA;AAAA,IAE1C,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA;AAAA,UAGE,KAAK,eAAe,oBAAoB,CAAC;AAAA;AAAA,IAE7C;AAAA,EACJ;AACF;AAEA,IAAM,4BAAN,cAAwC,sBAAsB;AAAA,EAC5D,YAAa,YAAY;AACvB,UAAM,YAAY,UAAU,cAAc,EAAE,QAAQ;AAEpD,SAAK,eAAe;AACpB,SAAK,WAAW;AAChB,SAAK,eAAe,KAAK,mBAAmB;AAC5C,SAAK,iBAAiB,UAAU,cAAc,EAAE;AAAA,EAClD;AAAA,EAEA,qBAAsB;AACpB,WAAO,UAAU,aAAa,aAC3B;AAAA,MACC;AAAA,MACA;AAAA,UACE,KAAK,eAAe,kBAAkB,CAAC;AAAA,UACvC,KAAK,eAAe,iBAAiB,CAAC;AAAA;AAAA;AAAA,YAGpC,KAAK,eAAe,YAAY,CAAC;AAAA;AAAA,IAEvC,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA;AAAA,UAGE,KAAK,eAAe,gBAAgB,CAAC;AAAA;AAAA,IAEzC,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA;AAAA,UAGE,KAAK,eAAe,iBAAiB,CAAC;AAAA;AAAA,IAE1C,EACC;AAAA,MACC;AAAA,MACA;AAAA;AAAA;AAAA,UAGE,KAAK,eAAe,oBAAoB,CAAC;AAAA;AAAA,IAE7C;AAAA,EACJ;AACF;AAEA,IAAM,uBAAN,cAAmC,eAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOhD,YAAa,QAAQ,OAAO;AAC1B,UAAM;AAMN,SAAK,iBAAiB;AACtB,SAAK,yBAAyB,OAAO;AAMrC,SAAK,cAAc;AAMnB,QAAI,KAAK,wBAAwB;AAC/B,WAAK,oBAAoB,OAAO,WAAW,SAAS;AAAA,IACtD,OACK;AACH,WAAK,oBAAoB,OAAO,SAAS;AAAA,IAC3C;AAEA,SAAK,cAAc;AACnB,SAAK,gBAAgB;AAAA,EACvB;AAAA,EAEA,gBAAiB;AACf,QAAI,gBAAgB,CAAC;AACrB,QAAI;AAEJ,QAAI,KAAK,wBAAwB;AAC/B,UAAI,KAAK,eAAe,OAAO;AAC7B,2BAAmB,KAAK,eAAe,MAAM;AAC7C,wBAAgB,KAAK,eAAe,MAAM;AAAA,MAC5C,OACK;AACH,2BAAmB,KAAK;AAExB,iBAAS,IAAI,GAAG,IAAI,kBAAkB,KAAK;AACzC,wBAAc,KAAK,CAAC;AAAA,QACtB;AAAA,MACF;AAAA,IACF,OACK;AACH,YAAM,kBAAkB,KAAK,eAAe,MAAM;AAClD,yBAAmB,kBAAkB;AAErC,eAAS,IAAI,GAAG,IAAI,iBAAiB,KAAK;AACxC,cAAM,OAAO,KAAK,eAAe,MAAM,CAAC;AACxC,sBAAc,KAAK,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AAAA,MAC3C;AAAA,IACF;AAEA,UAAM,cAAc,IAAI,YAAY,KAAK,cAAc,gBAAgB;AAEvE,SAAK,SAAS,IAAI,gBAAgB,aAAa,CAAC,CAAC;AAEjD,aAAS,IAAI,GAAG,IAAI,KAAK,aAAa,KAAK;AACzC,eAAS,IAAI,GAAG,IAAI,kBAAkB,KAAK;AACzC,oBAAY,IAAI,mBAAmB,CAAC,IAAI,cAAc,CAAC,IAAI,IAAI,KAAK;AAAA,MACtE;AAAA,IACF;AAAA,EACF;AAAA,EAEA,kBAAmB;AACjB,UAAM,iBAAiB,KAAK,gBAAgB,YAAY,CAAC,EAAE;AAE3D,QAAI,KAAK,wBAAwB;AAC/B,YAAM,YAAY,KAAK,eAAe,WAAW,SAAS;AAE1D,eAAS,IAAI,GAAG,SAAS,GAAG,IAAI,KAAK,aAAa,KAAK;AACrD,iBAAS,IAAI,GAAG,IAAI,KAAK,mBAAmB,KAAK,UAAU,GAAG;AAC5D,yBAAe,MAAU,IAAI,UAAU,IAAI,CAAC;AAC5C,yBAAe,SAAS,CAAC,IAAI,UAAU,IAAI,IAAI,CAAC;AAChD,yBAAe,SAAS,CAAC,IAAI,UAAU,IAAI,IAAI,CAAC;AAAA,QAClD;AAAA,MACF;AAAA,IACF,OACK;AACH,eAAS,IAAI,GAAG,SAAS,GAAG,IAAI,KAAK,aAAa,KAAK;AACrD,iBAAS,IAAI,GAAG,IAAI,KAAK,mBAAmB,KAAK,UAAU,GAAG;AAC5D,gBAAM,eAAe,KAAK,eAAe,SAAS,CAAC;AAEnD,yBAAe,MAAU,IAAI,aAAa;AAC1C,yBAAe,SAAS,CAAC,IAAI,aAAa;AAC1C,yBAAe,SAAS,CAAC,IAAI,aAAa;AAAA,QAC5C;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EAEA,YAAa;AACX,UAAM,WAAW,KAAK,gBAAgB,MAAM,CAAC,EAAE;AAE/C,QAAI,KAAK,wBAAwB;AAC/B,YAAM,MAAM,KAAK,eAAe,WAAW,GAAG;AAE9C,eAAS,IAAI,GAAG,SAAS,GAAG,IAAI,KAAK,aAAa,KAAK;AACrD,iBAAS,IAAI,GAAG,IAAI,KAAK,mBAAmB,KAAK,UAAU,GAAG;AAC5D,mBAAS,MAAU,IAAI,IAAI,IAAI,CAAC;AAChC,mBAAS,SAAS,CAAC,IAAI,IAAI,IAAI,IAAI,CAAC;AAAA,QACtC;AAAA,MACF;AAAA,IACF,OAAO;AACL,YAAM,kBAAkB,KAAK,eAAe,MAAM;AAClD,YAAM,MAAM,CAAC;AAEb,eAAS,IAAI,GAAG,IAAI,iBAAiB,KAAK;AACxC,cAAM,OAAO,KAAK,eAAe,MAAM,CAAC;AACxC,cAAM,KAAK,KAAK,eAAe,cAAc,CAAC,EAAE,CAAC;AAEjD,YAAI,KAAK,CAAC,IAAI,GAAG,CAAC;AAClB,YAAI,KAAK,CAAC,IAAI,GAAG,CAAC;AAClB,YAAI,KAAK,CAAC,IAAI,GAAG,CAAC;AAAA,MACpB;AAEA,eAAS,IAAI,GAAG,SAAS,GAAG,IAAI,KAAK,aAAa,KAAK;AACrD,iBAAS,IAAI,GAAG,IAAI,KAAK,mBAAmB,KAAK,UAAU,GAAG;AAC5D,gBAAM,KAAK,IAAI,CAAC;AAEhB,mBAAS,MAAM,IAAI,GAAG;AACtB,mBAAS,SAAS,CAAC,IAAI,GAAG;AAAA,QAC5B;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,gBAAiB,MAAM,UAAU,SAAS;AACxC,UAAM,SAAS,IAAI,aAAa,KAAK,cAAc,KAAK,oBAAoB,QAAQ;AACpF,UAAM,YAAY,IAAI,gBAAgB,QAAQ,QAAQ;AAEtD,SAAK,aAAa,MAAM,SAAS;AAEjC,QAAI,SAAS;AACX,YAAM,OAAO,CAAC;AAEd,eAAS,IAAI,GAAG,IAAI,KAAK,aAAa,KAAK;AACzC,gBAAQ,MAAM,GAAG,KAAK,WAAW;AACjC,aAAK,cAAc,WAAW,GAAG,IAAI;AAAA,MACvC;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,cAAe,WAAW,aAAa,MAAM;AAC3C,gBAAa,OAAO,cAAc,WAAY,KAAK,WAAW,SAAS,IAAI;AAE3E,QAAI,SAAS,cAAc,KAAK,oBAAoB,UAAU;AAE9D,aAAS,IAAI,GAAG,IAAI,KAAK,mBAAmB,KAAK;AAC/C,eAAS,IAAI,GAAG,IAAI,UAAU,UAAU,KAAK;AAC3C,kBAAU,MAAM,QAAQ,IAAI,KAAK,CAAC;AAAA,MACpC;AAAA,IACF;AAAA,EACF;AACF;AAEA,IAAM,4BAAN,cAAwC,eAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQrD,YAAa,SAAS,aAAa;AACjC,UAAM;AAEN,QAAI,MAAM,QAAQ,OAAO,GAAG;AAC1B,WAAK,mBAAmB;AAAA,IAC1B,OAAO;AACL,WAAK,mBAAmB,CAAC,OAAO;AAAA,IAClC;AAEA,SAAK,wBAAwB,KAAK,iBAAiB;AAMnD,SAAK,cAAc,cAAc,KAAK;AAKtC,SAAK,cAAc;AAMnB,SAAK,qBAAqB,KAAK,iBAAiB,IAAI,OAAK,EAAE,mBAAmB,EAAE,WAAW,SAAS,QAAQ,EAAE,SAAS,MAAM;AAK7H,SAAK,oBAAoB,KAAK,mBAAmB,OAAO,CAAC,GAAG,MAAM,IAAI,GAAG,CAAC;AAE1E,SAAK,cAAc;AACnB,SAAK,gBAAgB;AAAA,EACvB;AAAA,EAEA,gBAAiB;AACf,QAAI,mBAAmB;AAEvB,SAAK,gBAAgB,KAAK,iBAAiB,IAAI,cAAY;AACzD,UAAI,UAAU,CAAC;AAEf,UAAI,SAAS,kBAAkB;AAC7B,YAAI,SAAS,OAAO;AAClB,oBAAU,SAAS,MAAM;AAAA,QAC3B,OAAO;AACL,mBAAS,IAAI,GAAG,IAAI,SAAS,WAAW,SAAS,OAAO,KAAK;AAC3D,oBAAQ,KAAK,CAAC;AAAA,UAChB;AAAA,QACF;AAAA,MACF,OAAO;AACL,iBAAS,IAAI,GAAG,IAAI,SAAS,MAAM,QAAQ,KAAK;AAC9C,gBAAM,OAAO,SAAS,MAAM,CAAC;AAC7B,kBAAQ,KAAK,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AAAA,QACrC;AAAA,MACF;AAEA,0BAAoB,QAAQ;AAE5B,aAAO;AAAA,IACT,CAAC;AAED,UAAM,cAAc,IAAI,YAAY,mBAAmB,KAAK,WAAW;AACvE,QAAI,cAAc;AAClB,QAAI,eAAe;AAEnB,aAAS,IAAI,GAAG,IAAI,KAAK,aAAa,KAAK;AACzC,YAAM,QAAQ,IAAI,KAAK;AACvB,YAAM,UAAU,KAAK,cAAc,KAAK;AACxC,YAAM,cAAc,KAAK,mBAAmB,KAAK;AAEjD,eAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,oBAAY,aAAa,IAAI,QAAQ,CAAC,IAAI;AAAA,MAC5C;AAEA,sBAAgB;AAAA,IAClB;AAEA,SAAK,SAAS,IAAI,gBAAgB,aAAa,CAAC,CAAC;AAAA,EACnD;AAAA,EAEA,kBAAmB;AACjB,UAAM,iBAAiB,KAAK,gBAAgB,YAAY,CAAC,EAAE;AAE3D,UAAM,kBAAkB,KAAK,iBAAiB,IAAI,CAAC,UAAU,MAAM;AACjE,UAAI;AAEJ,UAAI,SAAS,kBAAkB;AAC7B,oBAAY,SAAS,WAAW,SAAS;AAAA,MAC3C,OAAO;AAEL,cAAM,cAAc,KAAK,mBAAmB,CAAC;AAE7C,oBAAY,CAAC;AAEb,iBAAS,IAAI,GAAG,SAAS,GAAG,IAAI,aAAa,KAAK;AAChD,gBAAM,eAAe,SAAS,SAAS,CAAC;AAExC,oBAAU,QAAQ,IAAI,aAAa;AACnC,oBAAU,QAAQ,IAAI,aAAa;AACnC,oBAAU,QAAQ,IAAI,aAAa;AAAA,QACrC;AAAA,MACF;AAEA,aAAO;AAAA,IACT,CAAC;AAED,aAAS,IAAI,GAAG,SAAS,GAAG,IAAI,KAAK,aAAa,KAAK;AACrD,YAAM,QAAQ,IAAI,KAAK,iBAAiB;AACxC,YAAM,cAAc,KAAK,mBAAmB,KAAK;AACjD,YAAM,YAAY,gBAAgB,KAAK;AAEvC,eAAS,IAAI,GAAG,IAAI,aAAa,KAAK;AACpC,uBAAe,QAAQ,IAAI,UAAU,IAAI,CAAC;AAC1C,uBAAe,QAAQ,IAAI,UAAU,IAAI,IAAI,CAAC;AAC9C,uBAAe,QAAQ,IAAI,UAAU,IAAI,IAAI,CAAC;AAAA,MAChD;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,YAAa;AACX,UAAM,WAAW,KAAK,gBAAgB,MAAM,CAAC,EAAE;AAC/C,UAAM,YAAY,KAAK,iBAAiB,IAAI,CAAC,UAAU,MAAM;AAC3D,UAAI;AAEJ,UAAI,SAAS,kBAAkB;AAC7B,YAAI,CAAC,SAAS,WAAW,IAAI;AAC3B,kBAAQ,MAAM,kCAAkC,QAAQ;AAAA,QAC1D;AAEA,cAAM,SAAS,WAAW,GAAG;AAAA,MAC/B,OAAO;AACL,cAAM,kBAAkB,KAAK,cAAc,CAAC,EAAE,SAAS;AACvD,cAAM,YAAY,CAAC;AAEnB,iBAAS,IAAI,GAAG,IAAI,iBAAiB,KAAK;AACxC,gBAAM,OAAO,SAAS,MAAM,CAAC;AAC7B,gBAAM,KAAK,SAAS,cAAc,CAAC,EAAE,CAAC;AAEtC,oBAAU,KAAK,CAAC,IAAI,GAAG,CAAC;AACxB,oBAAU,KAAK,CAAC,IAAI,GAAG,CAAC;AACxB,oBAAU,KAAK,CAAC,IAAI,GAAG,CAAC;AAAA,QAC1B;AAEA,cAAM,CAAC;AAEP,iBAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,cAAI,IAAI,CAAC,IAAI,UAAU,CAAC,EAAE;AAC1B,cAAI,IAAI,IAAI,CAAC,IAAI,UAAU,CAAC,EAAE;AAAA,QAChC;AAAA,MACF;AAEA,aAAO;AAAA,IACT,CAAC;AAED,aAAS,IAAI,GAAG,SAAS,GAAG,IAAI,KAAK,aAAa,KAAK;AAErD,YAAM,QAAQ,IAAI,KAAK,iBAAiB;AACxC,YAAM,cAAc,KAAK,mBAAmB,KAAK;AACjD,YAAM,MAAM,UAAU,KAAK;AAE3B,eAAS,IAAI,GAAG,IAAI,aAAa,KAAK;AACpC,iBAAS,QAAQ,IAAI,IAAI,IAAI,CAAC;AAC9B,iBAAS,QAAQ,IAAI,IAAI,IAAI,IAAI,CAAC;AAAA,MACpC;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWC,gBAAiB,MAAM,UAAU,SAAS;AACzC,UAAM,SAAS,IAAI,aAAa,KAAK,cAAc,KAAK,oBAAoB,QAAQ;AACpF,UAAM,YAAY,IAAI,gBAAgB,QAAQ,QAAQ;AAEtD,SAAK,aAAa,MAAM,SAAS;AAEjC,QAAI,SAAS;AACX,YAAM,OAAO,CAAC;AAEd,eAAS,IAAI,GAAG,IAAI,KAAK,aAAa,KAAK;AACzC,gBAAQ,MAAM,GAAG,KAAK,WAAW;AACjC,aAAK,cAAc,WAAW,GAAG,IAAI;AAAA,MACvC;AAAA,IACF;AAEA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUD,cAAe,WAAW,aAAa,MAAM;AAC3C,gBAAa,OAAO,cAAc,WAAY,KAAK,WAAW,SAAS,IAAI;AAE3E,UAAM,sBAAsB,cAAc,KAAK;AAC/C,UAAM,4BAA4B,KAAK,mBAAmB,mBAAmB;AAC7E,UAAM,SAAS,cAAc,KAAK,wBAAwB,KAAK,KAAK;AACpE,UAAM,cAAc,QAAQ,KAAK;AACjC,UAAM,OAAO,cAAc;AAC3B,QAAI,aAAa;AACjB,QAAI,IAAI;AAER,WAAM,IAAI,MAAM;AACd,oBAAc,KAAK,mBAAmB,GAAG;AAAA,IAC3C;AAEA,QAAI,UAAU,cAAc,cAAc,UAAU;AAEpD,aAASA,KAAI,GAAGA,KAAI,2BAA2BA,MAAK;AAClD,eAAS,IAAI,GAAG,IAAI,UAAU,UAAU,KAAK;AAC3C,kBAAU,MAAM,QAAQ,IAAI,KAAK,CAAC;AAAA,MACpC;AAAA,IACF;AAAA,EACF;AACF;AAEA,IAAM,gCAAN,cAA4C,wBAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOlE,YAAa,QAAQ,OAAO;AAC1B,UAAM;AAEN,SAAK,iBAAiB;AACtB,SAAK,KAAK,MAAM;AAEhB,SAAK,gBAAgB;AACrB,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,gBAAiB,MAAM,UAAU,SAAS;AACxC,UAAM,SAAS,IAAI,aAAa,KAAK,cAAc,QAAQ;AAC3D,UAAM,YAAY,IAAI,yBAAyB,QAAQ,QAAQ;AAE/D,SAAK,aAAa,MAAM,SAAS;AAEjC,QAAI,SAAS;AACX,YAAM,OAAO,CAAC;AAEd,eAAS,IAAI,GAAG,IAAI,KAAK,aAAa,KAAK;AACzC,gBAAQ,MAAM,GAAG,KAAK,WAAW;AACjC,aAAK,cAAc,WAAW,GAAG,IAAI;AAAA,MACvC;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,cAAe,WAAW,aAAa,MAAM;AAC3C,gBAAa,OAAO,cAAc,WAAY,KAAK,WAAW,SAAS,IAAI;AAE3E,QAAI,SAAS,cAAc,UAAU;AAErC,aAAS,IAAI,GAAG,IAAI,UAAU,UAAU,KAAK;AAC3C,gBAAU,MAAM,QAAQ,IAAI,KAAK,CAAC;AAAA,IACpC;AAAA,EACF;AACF;AAMA,IAAM,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOZ,eAAe,SAAU,UAAU;AACjC,QAAI,WAAW,CAAC;AAEhB,aAAS,IAAI,GAAG,KAAK,SAAS,MAAM,QAAQ,IAAI,IAAI,KAAK;AACvD,UAAI,IAAI,SAAS;AACjB,UAAI,OAAO,SAAS,MAAM,CAAC;AAE3B,UAAI,IAAI,KAAK;AACb,UAAI,IAAI,KAAK;AACb,UAAI,IAAI,KAAK;AAEb,UAAI,KAAK,SAAS,SAAS,CAAC;AAC5B,UAAI,KAAK,SAAS,SAAS,CAAC;AAC5B,UAAI,KAAK,SAAS,SAAS,CAAC;AAE5B,eAAS,KAAK,GAAG,MAAM,CAAC;AACxB,eAAS,KAAK,GAAG,MAAM,CAAC;AACxB,eAAS,KAAK,GAAG,MAAM,CAAC;AAExB,WAAK,IAAI;AACT,WAAK,IAAI,IAAI;AACb,WAAK,IAAI,IAAI;AAAA,IACf;AAEA,aAAS,WAAW;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,iBAAiB,SAAS,UAAU,MAAM,GAAG;AAC3C,QAAI,IAAI,SAAS,SAAS,KAAK,CAAC;AAChC,QAAI,IAAI,SAAS,SAAS,KAAK,CAAC;AAChC,QAAI,IAAI,SAAS,SAAS,KAAK,CAAC;AAEhC,QAAI,KAAK,IAAI,QAAQ;AAErB,MAAE,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK;AAC1B,MAAE,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK;AAC1B,MAAE,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK;AAE1B,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,aAAa,SAAS,KAAK,GAAG;AAC5B,QAAI,KAAK,IAAI,QAAQ;AAErB,MAAE,IAAI,UAAU,UAAU,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC;AAC9C,MAAE,IAAI,UAAU,UAAU,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC;AAC9C,MAAE,IAAI,UAAU,UAAU,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC;AAE9C,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,YAAY,SAAS,GAAG;AACtB,QAAI,KAAK,IAAI,QAAQ;AAErB,MAAE,IAAI,UAAU,gBAAgB,CAAG;AACnC,MAAE,IAAI,UAAU,gBAAgB,CAAG;AACnC,MAAE,IAAI,UAAU,gBAAgB,CAAG;AACnC,MAAE,UAAU;AAEZ,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,8BAA8B,SAAS,gBAAgB;AACrD,WAAO,IAAI,uBAAuB;AAAA,MAChC,UAAU,eAAe;AAAA,MACzB,SAAS,eAAe;AAAA,MACxB,iBAAiB,eAAe;AAAA,MAChC,kBAAkB,eAAe;AAAA,MACjC,YAAY,eAAe;AAAA,MAC3B,gBAAgB,eAAe;AAAA,IACjC,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,iCAAiC,SAAS,gBAAgB;AACxD,WAAO,IAAI,0BAA0B;AAAA,MACnC,UAAU,eAAe;AAAA,MACzB,SAAS,eAAe;AAAA,MACxB,iBAAiB,eAAe;AAAA,MAChC,kBAAkB,eAAe;AAAA,MACjC,YAAY,eAAe;AAAA,MAC3B,gBAAgB,eAAe;AAAA,IACjC,CAAC;AAAA,EACH;AACF;AAEA,IAAM,sBAAN,cAAkC,eAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAS/C,YAAa,OAAO,SAAS;AAC3B,UAAM;AAMN,SAAK,gBAAgB;AAMrB,SAAK,YAAY,KAAK,cAAc,MAAM;AAM1C,SAAK,cAAc,KAAK,cAAc,SAAS;AAE/C,cAAU,WAAW,CAAC;AACtB,YAAQ,oBAAoB,KAAK,iBAAiB;AAElD,SAAK,cAAc;AACnB,SAAK,gBAAgB,QAAQ,aAAa;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA,EAKA,mBAAoB;AAMlB,SAAK,YAAY,CAAC;AAElB,aAAS,IAAI,GAAG,IAAI,KAAK,WAAW,KAAK;AACvC,WAAK,UAAU,CAAC,IAAI,MAAM,gBAAgB,KAAK,eAAe,KAAK,cAAc,MAAM,CAAC,CAAC;AAAA,IAC3F;AAAA,EACF;AAAA,EAEA,gBAAiB;AACf,UAAM,cAAc,IAAI,YAAY,KAAK,YAAY,CAAC;AAEtD,SAAK,SAAS,IAAI,gBAAgB,aAAa,CAAC,CAAC;AAEjD,aAAS,IAAI,GAAG,SAAS,GAAG,IAAI,KAAK,WAAW,KAAK,UAAU,GAAG;AAChE,YAAM,OAAO,KAAK,cAAc,MAAM,CAAC;AAEvC,kBAAY,MAAU,IAAI,KAAK;AAC/B,kBAAY,SAAS,CAAC,IAAI,KAAK;AAC/B,kBAAY,SAAS,CAAC,IAAI,KAAK;AAAA,IACjC;AAAA,EACF;AAAA,EAEA,gBAAiB,eAAe;AAC9B,UAAM,iBAAiB,KAAK,gBAAgB,YAAY,CAAC,EAAE;AAC3D,QAAI,GAAG;AAEP,QAAI,kBAAkB,MAAM;AAC1B,WAAK,IAAI,GAAG,IAAI,KAAK,WAAW,KAAK;AACnC,cAAM,OAAO,KAAK,cAAc,MAAM,CAAC;AACvC,cAAM,WAAW,KAAK,YAAY,KAAK,UAAU,CAAC,IAAI,MAAM,gBAAgB,KAAK,eAAe,IAAI;AAEpG,cAAM,IAAI,KAAK,cAAc,SAAS,KAAK,CAAC;AAC5C,cAAM,IAAI,KAAK,cAAc,SAAS,KAAK,CAAC;AAC5C,cAAM,IAAI,KAAK,cAAc,SAAS,KAAK,CAAC;AAE5C,uBAAe,KAAK,IAAI,CAAC,IAAQ,EAAE,IAAI,SAAS;AAChD,uBAAe,KAAK,IAAI,IAAI,CAAC,IAAI,EAAE,IAAI,SAAS;AAChD,uBAAe,KAAK,IAAI,IAAI,CAAC,IAAI,EAAE,IAAI,SAAS;AAEhD,uBAAe,KAAK,IAAI,CAAC,IAAQ,EAAE,IAAI,SAAS;AAChD,uBAAe,KAAK,IAAI,IAAI,CAAC,IAAI,EAAE,IAAI,SAAS;AAChD,uBAAe,KAAK,IAAI,IAAI,CAAC,IAAI,EAAE,IAAI,SAAS;AAEhD,uBAAe,KAAK,IAAI,CAAC,IAAQ,EAAE,IAAI,SAAS;AAChD,uBAAe,KAAK,IAAI,IAAI,CAAC,IAAI,EAAE,IAAI,SAAS;AAChD,uBAAe,KAAK,IAAI,IAAI,CAAC,IAAI,EAAE,IAAI,SAAS;AAAA,MAClD;AAAA,IACF,OACK;AACH,WAAK,IAAI,GAAG,SAAS,GAAG,IAAI,KAAK,aAAa,KAAK,UAAU,GAAG;AAC9D,cAAM,SAAS,KAAK,cAAc,SAAS,CAAC;AAE5C,uBAAe,MAAU,IAAI,OAAO;AACpC,uBAAe,SAAS,CAAC,IAAI,OAAO;AACpC,uBAAe,SAAS,CAAC,IAAI,OAAO;AAAA,MACtC;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,YAAa;AACX,UAAM,WAAW,KAAK,gBAAgB,MAAM,CAAC,EAAE;AAE/C,aAAS,IAAI,GAAG,IAAI,KAAK,WAAW,KAAK;AAEvC,YAAM,OAAO,KAAK,cAAc,MAAM,CAAC;AACvC,UAAI;AAEJ,WAAK,KAAK,cAAc,cAAc,CAAC,EAAE,CAAC,EAAE,CAAC;AAC7C,eAAS,KAAK,IAAI,CAAC,IAAQ,GAAG;AAC9B,eAAS,KAAK,IAAI,IAAI,CAAC,IAAI,GAAG;AAE9B,WAAK,KAAK,cAAc,cAAc,CAAC,EAAE,CAAC,EAAE,CAAC;AAC7C,eAAS,KAAK,IAAI,CAAC,IAAQ,GAAG;AAC9B,eAAS,KAAK,IAAI,IAAI,CAAC,IAAI,GAAG;AAE9B,WAAK,KAAK,cAAc,cAAc,CAAC,EAAE,CAAC,EAAE,CAAC;AAC7C,eAAS,KAAK,IAAI,CAAC,IAAQ,GAAG;AAC9B,eAAS,KAAK,IAAI,IAAI,CAAC,IAAI,GAAG;AAAA,IAChC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,iBAAkB;AAChB,UAAM,kBAAkB,KAAK,gBAAgB,aAAa,CAAC,EAAE;AAC7D,UAAM,mBAAmB,KAAK,gBAAgB,cAAc,CAAC,EAAE;AAE/D,aAAS,IAAI,GAAG,IAAI,KAAK,aAAa,KAAK;AACzC,YAAM,YAAY,KAAK,cAAc,YAAY,CAAC;AAClD,YAAM,aAAa,KAAK,cAAc,YAAY,CAAC;AAEnD,sBAAgB,IAAI,CAAK,IAAI,UAAU;AACvC,sBAAgB,IAAI,IAAI,CAAC,IAAI,UAAU;AACvC,sBAAgB,IAAI,IAAI,CAAC,IAAI,UAAU;AACvC,sBAAgB,IAAI,IAAI,CAAC,IAAI,UAAU;AAEvC,uBAAiB,IAAI,CAAK,IAAI,WAAW;AACzC,uBAAiB,IAAI,IAAI,CAAC,IAAI,WAAW;AACzC,uBAAiB,IAAI,IAAI,CAAC,IAAI,WAAW;AACzC,uBAAiB,IAAI,IAAI,CAAC,IAAI,WAAW;AAAA,IAC3C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,gBAAiB,MAAM,UAAU,SAAS;AACxC,UAAM,SAAS,IAAI,aAAa,KAAK,cAAc,QAAQ;AAC3D,UAAM,YAAY,IAAI,gBAAgB,QAAQ,QAAQ;AAEtD,SAAK,aAAa,MAAM,SAAS;AAEjC,QAAI,SAAS;AACX,YAAM,OAAO,CAAC;AAEd,eAAS,IAAI,GAAG,IAAI,KAAK,WAAW,KAAK;AACvC,gBAAQ,MAAM,GAAG,KAAK,SAAS;AAC/B,aAAK,YAAY,WAAW,GAAG,IAAI;AAAA,MACrC;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,YAAa,WAAW,WAAW,MAAM;AACvC,gBAAa,OAAO,cAAc,WAAY,KAAK,WAAW,SAAS,IAAI;AAE3E,QAAI,SAAS,YAAY,IAAI,UAAU;AAEvC,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,eAAS,IAAI,GAAG,IAAI,UAAU,UAAU,KAAK;AAC3C,kBAAU,MAAM,QAAQ,IAAI,KAAK,CAAC;AAAA,MACpC;AAAA,IACF;AAAA,EACF;AACF;AAEA,IAAM,sBAAN,cAAkC,eAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAM/C,YAAa,OAAO;AAClB,UAAM;AAMN,SAAK,aAAa;AAElB,SAAK,gBAAgB;AAAA,EACvB;AAAA,EAEA,kBAAmB;AACjB,SAAK,gBAAgB,YAAY,CAAC;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,gBAAiB,MAAM,UAAU,SAAS;AACxC,UAAM,SAAS,IAAI,aAAa,KAAK,aAAa,QAAQ;AAC1D,UAAM,YAAY,IAAI,gBAAgB,QAAQ,QAAQ;AAEtD,SAAK,aAAa,MAAM,SAAS;AAEjC,QAAI,SAAS;AACX,YAAM,OAAO,CAAC;AACd,eAAS,IAAI,GAAG,IAAI,KAAK,YAAY,KAAK;AACxC,gBAAQ,MAAM,GAAG,KAAK,UAAU;AAChC,aAAK,aAAa,WAAW,GAAG,IAAI;AAAA,MACtC;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,aAAc,WAAW,YAAY,MAAM;AACzC,gBAAa,OAAO,cAAc,WAAY,KAAK,WAAW,SAAS,IAAI;AAE3E,QAAI,SAAS,aAAa,UAAU;AAEpC,aAAS,IAAI,GAAG,IAAI,UAAU,UAAU,KAAK;AAC3C,gBAAU,MAAM,QAAQ,IAAI,KAAK,CAAC;AAAA,IACpC;AAAA,EACF;AACF;AAEA,IAAI,qBAAqB;AAEzB,IAAI,eAAe;AAEnB,IAAI,eAAe;AAEnB,IAAI,mBAAmB;AAEvB,IAAI,gBAAgB;AAEpB,IAAI,cAAc;AAElB,IAAI,iBAAiB;AAErB,IAAI,qBAAqB;AAEzB,IAAI,kBAAkB;AAEtB,IAAI,eAAe;AAEnB,IAAI,mBAAmB;AAEvB,IAAI,gBAAgB;AAEpB,IAAI,gBAAgB;AAEpB,IAAI,oBAAoB;AAExB,IAAI,iBAAiB;AAErB,IAAI,kBAAkB;AAEtB,IAAI,sBAAsB;AAE1B,IAAI,mBAAmB;AAEvB,IAAI,eAAe;AAEnB,IAAI,mBAAmB;AAEvB,IAAI,gBAAgB;AAEpB,IAAI,eAAe;AAEnB,IAAI,mBAAmB;AAEvB,IAAI,gBAAgB;AAEpB,IAAI,gBAAgB;AAEpB,IAAI,oBAAoB;AAExB,IAAI,iBAAiB;AAErB,IAAI,gBAAgB;AAEpB,IAAI,oBAAoB;AAExB,IAAI,iBAAiB;AAErB,IAAI,eAAe;AAEnB,IAAI,mBAAmB;AAEvB,IAAI,gBAAgB;AAEpB,IAAI,mBAAmB;AAEvB,IAAI,sBAAsB;AAE1B,IAAI,mBAAmB;AAKvB,IAAM,cAAc;AAAA,EAClB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAEF;AAYA,SAAS,gBAAgB,KAAK,OAAO,UAAU,YAAY,UAAU;AACnE,OAAK,MAAM;AACX,OAAK,QAAQ;AACb,OAAK,WAAW;AAChB,OAAK,aAAa;AAClB,OAAK,WAAW;AAEhB,OAAK,QAAQ;AACf;AAEA,gBAAgB,UAAU,UAAU,WAAW;AAC7C,SAAO,KAAK,SAAS,IAAI;AAC3B;AAEA,OAAO,eAAe,gBAAgB,WAAW,OAAO;AAAA,EACtD,KAAK,WAAW;AACd,WAAO,KAAK,QAAQ,KAAK;AAAA,EAC3B;AACF,CAAC;AAOD,SAAS,WAAW;AAKlB,OAAK,WAAW;AAMhB,OAAK,UAAU;AAEf,OAAK,WAAW,CAAC;AACjB,OAAK,QAAQ;AACf;AAGA,SAAS,qBAAqB,CAAC;AAU/B,SAAS,WAAW,SAAS,KAAK,YAAY;AAC5C,WAAS,mBAAmB,GAAG,IAAI;AAEnC,SAAO;AACT;AASA,SAAS,UAAU,MAAM,SAAS,UAAU,aAAa,gBAAgB;AAEvE,QAAM,QAAQ;AAEd,MAAI,QAAQ,KAAK;AAEjB,MAAI,mBAAmB,QAAW;AAChC,QAAI,OAAO,mBAAmB,UAAU;AACtC,cAAQ;AAAA,IACV,WACS,OAAO,mBAAmB,UAAU;AAC3C,YAAM,UAAU,cAAc;AAAA,IAChC;AAEA,SAAK,WAAW,KAAK,IAAI,KAAK,UAAU,QAAQ,QAAQ;AAAA,EAC1D,OACK;AACH,SAAK,YAAY;AAAA,EACnB;AAEA,MAAI,OAAO,OAAO,KAAK,WAAW,GAAG;AAErC,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,UAAM,KAAK,CAAC;AAEZ,SAAK,kBAAkB,KAAK,YAAY,GAAG,GAAG,OAAO,QAAQ;AAAA,EAC/D;AACF;AAEA,SAAS,UAAU,oBAAoB,SAAS,KAAK,YAAY,OAAO,UAAU;AAChF,QAAM,aAAa,SAAS,mBAAmB,GAAG;AAElD,MAAI,WAAW,KAAK,SAAS,GAAG;AAChC,MAAI,CAAC,SAAU,YAAW,KAAK,SAAS,GAAG,IAAI,CAAC;AAEhD,MAAI,WAAW,SAAS,QAAW;AACjC,QAAI,SAAS,WAAW,GAAG;AACzB,iBAAW,OAAO,WAAW;AAAA,IAC/B,OACK;AACH,iBAAW,OAAO,SAAS,SAAS,SAAS,CAAC,EAAE,WAAW;AAAA,IAC7D;AAAA,EACF;AAEA,WAAS,KAAK,IAAI,iBAAiB,KAAK,SAAS,SAAS,GAAG,OAAO,UAAU,YAAY,WAAW,QAAQ,CAAC;AAChH;AAMA,SAAS,UAAU,UAAU,WAAW;AACtC,QAAM,IAAI,CAAC;AAEX,QAAM,OAAO,OAAO,KAAK,KAAK,QAAQ;AACtC,MAAI;AAEJ,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,eAAW,KAAK,SAAS,KAAK,CAAC,CAAC;AAEhC,SAAK,SAAS,QAAQ;AAEtB,aAAS,QAAQ,SAAS,GAAG;AAC3B,QAAE,KAAK,EAAE,QAAQ,CAAC;AAAA,IACpB,CAAC;AAAA,EACH;AAEA,SAAO;AACT;AACA,SAAS,UAAU,WAAW,SAAS,UAAU;AAC/C,MAAI,SAAS,WAAW,EAAG;AAE3B,MAAI,IAAI;AAER,WAAS,IAAI,GAAG,IAAI,SAAS,SAAS,GAAG,KAAK;AAC5C,SAAK,SAAS,CAAC;AACf,SAAK,SAAS,IAAI,CAAC;AAEnB,OAAG,QAAQ,GAAG,QAAQ,GAAG;AAAA,EAC3B;AAGA,OAAK,SAAS,SAAS,SAAS,CAAC;AACjC,KAAG,QAAQ,KAAK,WAAW,GAAG;AAChC;AAQA,SAAS,UAAU,oBAAoB,SAAS,KAAK;AACnD,MAAI,IAAI,KAAK;AAEb,SAAO,KAAK,SAAS,GAAG,IAAK,KAAK,SAAS,GAAG,EAAE,IAAI,SAAS,GAAG;AAC9D,WAAO,iBAAiB,EAAE,GAAG,IAAI,CAAC;AAAA,EACpC,CAAC,EAAE,KAAK,IAAI,IAAI;AAClB;AAEA,IAAM,iBAAiB;AAAA,EACrB,MAAM,SAAS,GAAG,GAAG,GAAG;AACtB,UAAM,KAAK,EAAE,KAAK,GAAG,YAAY,CAAC;AAClC,UAAM,KAAK,EAAE,KAAK,GAAG,YAAY,CAAC;AAClC,UAAM,KAAK,EAAE,KAAK,GAAG,YAAY,CAAC;AAElC,WAAO,QAAQ,CAAC,WAAW,CAAC,KAAK,CAAC,KAAK,CAAC;AAAA,EAC1C;AAAA,EACA,MAAM,SAAS,GAAG,GAAG,GAAG;AACtB,UAAM,KAAK,EAAE,KAAK,GAAG,YAAY,CAAC;AAClC,UAAM,KAAK,EAAE,KAAK,GAAG,YAAY,CAAC;AAClC,UAAM,KAAK,EAAE,KAAK,GAAG,YAAY,CAAC;AAClC,UAAM,KAAK,EAAE,KAAK,GAAG,YAAY,CAAC;AAElC,WAAO,QAAQ,CAAC,WAAW,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC;AAAA,EAChD;AAAA,EACA,eAAe,SAAS,SAAS;AAC/B,WAAO;AAAA,kBACO,QAAQ,GAAG,MAAM,QAAQ,MAAM,YAAY,CAAC,CAAC;AAAA,qBAC1C,QAAQ,GAAG,MAAM,QAAQ,SAAS,YAAY,CAAC,CAAC;AAAA;AAAA,EAEnE;AAAA,EACA,UAAU,SAAS,SAAS;AAE1B,QAAI,QAAQ,aAAa,GAAG;AAC1B,aAAO;AAAA,IACT,OACK;AACH,aAAO;AAAA,4CAC+B,QAAQ,GAAG,mBAAmB,QAAQ,GAAG,gBAAgB,QAAQ,GAAG;AAAA,QACxG,QAAQ,WAAW,OAAO,cAAc,QAAQ,WAAW,IAAI,YAAa,QAAQ,WAAW,aAAa,KAAK,QAAQ,WAAW,WAAW,IAAI,CAAC,MAAM,EAAE,YAAY,CAAC,CAAC,EAAE,KAAK,IAAI,CAAC,KAAK,EAAG,OAAO,EAAE;AAAA;AAAA,IAE3M;AAAA,EACF;AAAA,EACA,aAAa,SAAS,SAAS;AAC7B,UAAM,YAAY,QAAQ,MAAM,YAAY,CAAC;AAC7C,UAAM,WAAW,QAAQ,MAAM,QAAQ,OAAO,YAAY,CAAC;AAE3D,WAAO,cAAc,SAAS,cAAc,OAAO;AAAA,EACrD;AACF;AAEA,IAAM,qBAAqB;AAAA,EACzB,UAAU,SAAS,SAAS;AAC1B,WAAO;AAAA,MACL,eAAe,cAAc,OAAO,CAAC;AAAA,MACrC,eAAe,KAAK,iBAAiB,QAAQ,GAAG,IAAI,QAAQ,WAAW,MAAM,CAAC,CAAC;AAAA,MAC/E,eAAe,KAAK,eAAe,QAAQ,GAAG,IAAI,QAAQ,WAAW,IAAI,CAAC,CAAC;AAAA;AAAA,yBAExD,QAAQ,GAAG;AAAA;AAAA,QAE5B,eAAe,YAAY,OAAO,CAAC;AAAA,QACnC,eAAe,SAAS,OAAO,CAAC;AAAA;AAAA,+BAET,QAAQ,GAAG,iBAAiB,QAAQ,GAAG;AAAA;AAAA;AAAA,EAGpE;AAAA,EACA,aAAa,IAAI,QAAQ,GAAG,GAAG,CAAC;AAClC;AAEA,SAAS,SAAS,aAAa,kBAAkB;AAEjD,IAAM,eAAe;AAAA,EACnB,UAAU,SAAS,SAAS;AAC1B,UAAM,SAAS,QAAQ,WAAW;AAElC,WAAO;AAAA,MACL,eAAe,cAAc,OAAO,CAAC;AAAA,MACrC,eAAe,KAAK,aAAa,QAAQ,GAAG,IAAI,QAAQ,WAAW,MAAM,CAAC,CAAC;AAAA,MAC3E,eAAe,KAAK,WAAW,QAAQ,GAAG,IAAI,QAAQ,WAAW,IAAI,CAAC,CAAC;AAAA,MACvE,SAAS,eAAe,KAAK,UAAU,QAAQ,GAAG,IAAI,QAAQ,CAAC,IAAI,EAAE;AAAA;AAAA,yBAElD,QAAQ,GAAG;AAAA;AAAA,QAE5B,eAAe,YAAY,OAAO,CAAC;AAAA,QACnC,eAAe,SAAS,OAAO,CAAC;AAAA;AAAA,QAEhC,SAAS,eAAe,QAAQ,GAAG,MAAM,EAAE;AAAA,2BACxB,QAAQ,GAAG,aAAa,QAAQ,GAAG;AAAA,QACtD,SAAS,eAAe,QAAQ,GAAG,MAAM,EAAE;AAAA;AAAA;AAAA,EAGjD;AAAA,EACA,aAAa,IAAI,QAAQ,GAAG,GAAG,CAAC;AAClC;AAEA,SAAS,SAAS,SAAS,YAAY;AAEvC,IAAM,kBAAkB;AAAA,EACtB,SAAS,SAAS;AAChB,UAAM,gBAAgB,IAAI;AAAA,MACxB,QAAQ,WAAW,KAAK,KAAK;AAAA,MAC7B,QAAQ,WAAW,KAAK,KAAK;AAAA,MAC7B,QAAQ,WAAW,KAAK,KAAK;AAAA,MAC7B,QAAQ,WAAW,KAAK;AAAA,IAC1B;AAEA,UAAM,SAAS,QAAQ,WAAW,GAAG,QAAQ,QAAQ,WAAW,KAAK;AACrE,UAAM,cAAc,IAAI;AAAA,MACtB,OAAO;AAAA,MACP,OAAO;AAAA,MACP,OAAO;AAAA,MACP,QAAQ,WAAW,GAAG;AAAA,IACxB;AAEA,UAAM,SAAS,QAAQ,WAAW;AAElC,WAAO;AAAA,MACL,eAAe,cAAc,OAAO,CAAC;AAAA,MACrC,eAAe,KAAK,gBAAgB,QAAQ,GAAG,IAAI,eAAe,CAAC,CAAC;AAAA,MACpE,eAAe,KAAK,cAAc,QAAQ,GAAG,IAAI,aAAa,CAAC,CAAC;AAAA,MAChE,SAAS,eAAe,KAAK,UAAU,QAAQ,GAAG,IAAI,QAAQ,CAAC,IAAI,EAAE;AAAA;AAAA,yBAElD,QAAQ,GAAG;AAAA,QAC5B,eAAe,YAAY,OAAO,CAAC;AAAA,QACnC,eAAe,SAAS,OAAO,CAAC;AAAA;AAAA,QAEhC,SAAS,eAAe,QAAQ,GAAG,MAAM,EAAE;AAAA,+CACJ,QAAQ,GAAG,oBAAoB,QAAQ,GAAG;AAAA,uCAClD,QAAQ,GAAG,kBAAkB,QAAQ,GAAG;AAAA;AAAA;AAAA,QAGvE,SAAS,eAAe,QAAQ,GAAG,MAAM,EAAE;AAAA;AAAA;AAAA,EAGjD;AAAA,EACA,aAAa,EAAC,MAAM,IAAI,QAAQ,GAAG,OAAO,EAAC;AAC7C;AAEA,SAAS,SAAS,UAAU,eAAe;",
  "names": ["i"]
}
